Index: output/nusmvfile.smv
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>MODULE main\nVAR\n\tk3: boolean;\n\thl: boolean;\n\tdp: boolean;\n\nLTLSPEC !(G ((hl & k3) -> dp) & G (!k3 | X k3))\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/output/nusmvfile.smv b/output/nusmvfile.smv
--- a/output/nusmvfile.smv	(revision bb18496a6cc3a638dab82652523c81472eccf5fb)
+++ b/output/nusmvfile.smv	(date 1655488429901)
@@ -1,7 +1,8 @@
 MODULE main
 VAR
-	k3: boolean;
-	hl: boolean;
-	dp: boolean;
+	r1: boolean;
+	r3: boolean;
+	r4: boolean;
+	r2: boolean;
 
-LTLSPEC !(G ((hl & k3) -> dp) & G (!k3 | X k3))
+LTLSPEC !(G F (r3 & F r4) & (!r4 U r3) & G (r4 -> X (!r4 U r3)) & G (r3 -> X (!r3 U r4)) & G F (r1 & F r2) & (!r2 U r1) & G (r2 -> X (!r2 U r1)) & G (r1 -> X (!r1 U r2)) & G (!r3 | X r3 | X r4) & G (!r4 | X r3 | X r4) & G (!r1 | X r1 | X r2) & G (!r2 | X r1 | X r2) & G ((!r1 & !r2 & r3 & !r4) | (!r1 & r2 & !r3 & !r4) | (!r1 & !r2 & !r3 & r4) | (r1 & !r2 & !r3 & !r4)))
Index: crome_logic/patterns/robotic_triggers.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\n\nfrom dataclasses import dataclass, field\n\nfrom crome_logic.patterns import Pattern, PatternKind\nfrom crome_logic.tools.logic import Logic\n\n\n@dataclass\nclass Trigger(Pattern):\n    kind: PatternKind = field(init=False, default=PatternKind.ROBOTIC_TRIGGER)\n    pre: str\n    post: str\n\n\n@dataclass\nclass InstantaneousReaction(Trigger):\n\n    def __post_init__(self):\n        self.name = \"Instantaneous Reaction\"\n        self.description = \"The occurrence of a stimulus instantaneously triggers a counteraction.\"\n        self.formula = Logic.g_(Logic.implies_(self.pre, self.post))\n\n\n@dataclass\nclass BoundReaction(Trigger):\n\n    def __post_init__(self):\n        self.name = \"Bound Reaction\"\n        self.description = \"A counteraction must be performed every time and only when a specific location is entered.\"\n        self.formula = Logic.g_(Logic.iff_(self.pre, self.post))\n\n\n@dataclass\nclass BoundDelay(Trigger):\n\n    def __post_init__(self):\n        self.name = \"Bound Delay\"\n        self.description = \"A counteraction must be performed, in the next time instant, every time and only when a \" \\\n                           \"specific location is entered.\"\n        self.formula = Logic.g_(Logic.iff_(self.pre, Logic.x_(self.post)))\n\n\n@dataclass\nclass PromptReaction(Trigger):\n\n    def __post_init__(self):\n        self.name = \"Prompt Reaction\"\n        self.description = \"The occurrence of a stimulus triggers a counteraction promptly, i.e in the next time \" \\\n                           \"instant.\"\n        self.formula = Logic.g_(Logic.implies_(self.pre, Logic.x_(self.post)))\n\n\n@dataclass\nclass DelayedReaction(Trigger):\n\n    def __post_init__(self):\n        self.name = \"Delayed Reaction\"\n        self.description = \"The occurrence of a stimulus triggers a counteraction some time later.\"\n        self.formula = Logic.g_(Logic.implies_(self.pre, Logic.f_(self.post)))\n\n\n@dataclass\nclass Wait(Trigger):\n\n    def __post_init__(self):\n        self.name = \"Wait\"\n        self.description = \"Inaction is desired till a stimulus occurs.\"\n        self.formula = Logic.u_(self.pre, self.post)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crome_logic/patterns/robotic_triggers.py b/crome_logic/patterns/robotic_triggers.py
--- a/crome_logic/patterns/robotic_triggers.py	(revision bb18496a6cc3a638dab82652523c81472eccf5fb)
+++ b/crome_logic/patterns/robotic_triggers.py	(date 1655174268932)
@@ -6,19 +6,76 @@
 from crome_logic.tools.logic import Logic
 
 
+
+
 @dataclass
 class Trigger(Pattern):
     kind: PatternKind = field(init=False, default=PatternKind.ROBOTIC_TRIGGER)
     pre: str
     post: str
 
+    @classmethod
+    def iterate_over_preconditions(cls, preconditions: list[str], post: str):
+        p = Pattern()
+        for pre in preconditions:
+            p &= cls(pre=pre, post=post)
+        return p
+
+
+
+@dataclass
+class InitInstantaneousReaction(Trigger):
+
+    def __post_init__(self):
+        self.name = "Init Instantaneous Reaction"
+        self.description = "At the first step, the occurrence of a stimulus instantaneously triggers a counteraction."
+        self.formula = (Logic.implies_(self.pre, self.post))
+
+
+@dataclass
+class InitBoundReaction(Trigger):
+
+    def __post_init__(self):
+        self.name = "Init Bound Reaction"
+        self.description = "At the first step, a counteraction must be performed every time and only when a specific location is entered."
+        self.formula = (Logic.iff_(self.pre, self.post))
+
+
+@dataclass
+class InitBoundDelay(Trigger):
+
+    def __post_init__(self):
+        self.name = "Init Bound Delay"
+        self.description = "At the first step, a counteraction must be performed, in the next time instant, every time and only when a " \
+                           "specific location is entered."
+        self.formula = (Logic.iff_(self.pre, Logic.x_(self.post)))
+
+
+@dataclass
+class InitPromptReaction(Trigger):
+
+    def __post_init__(self):
+        self.name = "Init Prompt Reaction"
+        self.description = "At the first step, the occurrence of a stimulus triggers a counteraction promptly, i.e in the next time " \
+                           "instant."
+        self.formula = (Logic.implies_(self.pre, Logic.x_(self.post)))
+
+
+@dataclass
+class InitDelayedReaction(Trigger):
+
+    def __post_init__(self):
+        self.name = "Init Delayed Reaction"
+        self.description = "At the first step, the occurrence of a stimulus triggers a counteraction some time later."
+        self.formula = (Logic.implies_(self.pre, Logic.f_(self.post)))
+
 
 @dataclass
 class InstantaneousReaction(Trigger):
 
     def __post_init__(self):
-        self.name = "Instantaneous Reaction"
-        self.description = "The occurrence of a stimulus instantaneously triggers a counteraction."
+        self.name = "Init Instantaneous Reaction"
+        self.description = "At the first step, the occurrence of a stimulus instantaneously triggers a counteraction."
         self.formula = Logic.g_(Logic.implies_(self.pre, self.post))
 
 
Index: crome_logic/patterns/basic.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\n\nfrom dataclasses import dataclass, field\n\nfrom crome_logic.patterns import Pattern, PatternKind\n\n\n@dataclass\nclass Init(Pattern):\n    element: str\n\n    def __post_init__(self):\n        self.kind = PatternKind.BASIC\n        self.formula = self.element\n\n\n@dataclass\nclass G(Pattern):\n    element: str\n\n    def __post_init__(self):\n        self.kind = PatternKind.BASIC\n        self.formula = f\"G({self.element})\"\n\n\n@dataclass\nclass F(Pattern):\n    element: str\n\n    def __post_init__(self):\n        self.kind = PatternKind.BASIC\n        self.formula = f\"F{self.element}\"\n\n\n@dataclass\nclass X(Pattern):\n    element: str\n\n    def __post_init__(self):\n        self.kind = PatternKind.BASIC\n        self.formula = f\"X{self.element}\"\n\n\n@dataclass\nclass GF(Pattern):\n    element: str\n\n    def __post_init__(self):\n        self.kind = PatternKind.BASIC\n        self.formula = f\"GF{self.element}\"\n\n\n@dataclass\nclass U(Pattern):\n    pre: str\n    post: str\n\n    def __post_init__(self):\n        self.kind = PatternKind.BASIC\n        self.formula = f\"(({self.pre}) U ({self.post}))\"\n\n\n@dataclass\nclass W(Pattern):\n    pre: str\n    post: str\n\n    def __post_init__(self):\n        self.kind = PatternKind.BASIC\n        self.formula = f\"((({self.pre}) U ({self.post})) | G({self.pre}))\"\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crome_logic/patterns/basic.py b/crome_logic/patterns/basic.py
--- a/crome_logic/patterns/basic.py	(revision bb18496a6cc3a638dab82652523c81472eccf5fb)
+++ b/crome_logic/patterns/basic.py	(date 1654882137303)
@@ -50,6 +50,11 @@
         self.formula = f"GF{self.element}"
 
 
+@dataclass
+class InfOft(GF):
+    pass
+
+
 @dataclass
 class U(Pattern):
     pre: str
Index: crome_logic/specification/rules_extractors.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from crome_logic.specification import Specification\nfrom crome_logic.specification.string_logic import and_, f_, g_, implies_, not_, or_, x_\nfrom crome_logic.specification.temporal import LTL\nfrom crome_logic.typelement import TypeKind\nfrom crome_logic.typelement.basic import Boolean\nfrom crome_logic.typeset import Typeset\n\n\ndef extract_refinement_rules(\n    typeset: Typeset,\n    output_list: bool = False,\n) -> LTL | tuple[list[str], Typeset]:\n    \"\"\"Extract Refinement rules from the Formula.\"\"\"\n\n    rules_str = []\n    rules_typeset: Typeset = Typeset()\n\n    for key_type, set_super_types in typeset.super_types.items():\n        if isinstance(key_type, Boolean):\n            for super_type in set_super_types:\n                rules_str.append(\n                    g_(\n                        implies_(\n                            key_type.name,\n                            super_type.name,\n                        ),\n                    ),\n                )\n                rules_typeset += Typeset({key_type})\n                rules_typeset += Typeset(set_super_types)\n\n\n    if output_list:\n        return rules_str, rules_typeset\n\n    if len(rules_str) == 0:\n        return LTL(\"TRUE\")\n\n    return LTL(\n        _init_formula=and_(rules_str, brackets=True),\n        _typeset=rules_typeset,\n        _kind=Specification.Kind.Rule.REFINEMENT,\n    )\n\n\ndef extract_mutex_rules(\n    typeset: Typeset,\n    output_list: bool = False,\n) -> LTL | tuple[list[str], Typeset]:\n    \"\"\"Extract Mutex rules from the Formula.\"\"\"\n\n    rules_str = []\n    rules_typeset: Typeset = Typeset()\n\n    for mutex_group in typeset.mutex_types:\n        or_elements = []\n        if len(mutex_group) > 1:\n            for mutex_type in mutex_group:\n                neg_group = mutex_group.symmetric_difference({mutex_type})\n                and_elements = [mutex_type.name]\n                for elem in neg_group:\n                    and_elements.append(not_(elem.name))\n                or_elements.append(and_(and_elements, brackets=True))\n            rules_str.append(\n                g_(or_(or_elements, brackets=False)),\n            )\n            rules_typeset += Typeset(set(mutex_group))\n\n    if output_list:\n        return rules_str, rules_typeset\n\n    if len(rules_str) == 0:\n        return LTL(\"TRUE\")\n\n    return LTL(\n        _init_formula=and_(rules_str, brackets=True),\n        _typeset=rules_typeset,\n        _kind=Specification.Kind.Rule.MUTEX,\n    )\n\n\ndef extract_adjacency_rules(\n    typeset: Typeset,\n    output_list: bool = False,\n) -> LTL | tuple[list[str], Typeset]:\n    \"\"\"Extract Adjacency rules from the Formula.\"\"\"\n\n    rules_str = []\n    rules_typeset: Typeset = Typeset()\n\n    for key_type, set_adjacent_types in typeset.adjacent_types.items():\n        if isinstance(key_type, Boolean):\n            # G(a -> X(b | c | d))\n            rules_str.append(\n                g_(\n                    implies_(\n                        key_type.name,\n                        x_(\n                            or_(\n                                [e.name for e in set_adjacent_types],\n                            ),\n                        ),\n                    ),\n                ),\n            )\n            rules_typeset += Typeset({key_type})\n            rules_typeset += Typeset(set_adjacent_types)\n\n    if output_list:\n        return rules_str, rules_typeset\n\n    if len(rules_str) == 0:\n        return LTL(\"TRUE\")\n\n    return LTL(\n        _init_formula=and_(rules_str, brackets=True),\n        _typeset=rules_typeset,\n        _kind=Specification.Kind.Rule.ADJACENCY,\n    )\n\n\ndef extract_liveness_rules(\n    typeset: Typeset,\n    output_list: bool = False,\n) -> LTL | tuple[list[str], Typeset] | None:\n    \"\"\"Extract Liveness rules from the Formula.\"\"\"\n\n    rules_str = []\n    rules_typeset: Typeset = Typeset()\n\n    sensors, outs = typeset.extract_inputs_outputs()\n\n    for t in sensors:\n        if isinstance(t, Boolean):\n            if t.kind == TypeKind.SENSOR:\n                rules_str.append(g_(f_(t.name)))\n            rules_typeset += Typeset({t})\n\n    if output_list:\n        return rules_str, rules_typeset\n\n    if len(rules_str) == 0:\n        return LTL(\"TRUE\")\n\n    return LTL(\n        _init_formula=and_(rules_str, brackets=True),\n        _typeset=rules_typeset,\n        _kind=Specification.Kind.Rule.LIVENESS,\n    )\n\n\ndef context_active_rules(\n    typeset: Typeset,\n    output_list: bool = False,\n) -> LTL | tuple[list[str], Typeset] | None:\n    \"\"\"Extract Liveness rules from the Formula.\"\"\"\n\n    rules_str = []\n    rules_typeset: Typeset = Typeset()\n\n    inputs, outs = typeset.extract_inputs_outputs()\n\n    active_context_types = []\n    for t in inputs:\n        if isinstance(t, Boolean):\n            if t.kind == TypeKind.ACTIVE or t.kind == TypeKind.CONTEXT:\n                active_context_types.append(t.name)\n            rules_typeset += Typeset({t})\n\n    if len(active_context_types) > 0:\n        rules_str.append(g_(and_(active_context_types)))\n\n    if len(rules_str) == 0:\n        return None\n\n    if output_list:\n        return rules_str, rules_typeset\n\n    return LTL(\n        _init_formula=and_(rules_str, brackets=True),\n        _typeset=rules_typeset,\n        _kind=Specification.Kind.Rule.LIVENESS,\n    )\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crome_logic/specification/rules_extractors.py b/crome_logic/specification/rules_extractors.py
--- a/crome_logic/specification/rules_extractors.py	(revision bb18496a6cc3a638dab82652523c81472eccf5fb)
+++ b/crome_logic/specification/rules_extractors.py	(date 1655327452527)
@@ -1,5 +1,5 @@
 from crome_logic.specification import Specification
-from crome_logic.specification.string_logic import and_, f_, g_, implies_, not_, or_, x_
+from crome_logic.specification.string_logic import and_, f_, g_, implies_, not_, or_, x_, iff_
 from crome_logic.specification.temporal import LTL
 from crome_logic.typelement import TypeKind
 from crome_logic.typelement.basic import Boolean
@@ -7,8 +7,44 @@
 
 
 def extract_refinement_rules(
-    typeset: Typeset,
-    output_list: bool = False,
+        typeset: Typeset,
+        output_list: bool = False,
+) -> LTL | tuple[list[str], Typeset]:
+    """Extract Refinement rules from the Formula."""
+
+    rules_str = []
+    rules_typeset: Typeset = Typeset()
+
+    refinements: dict[Boolean, set[Boolean]] = {}
+
+    for key_type, set_super_types in typeset.super_types.items():
+        if isinstance(key_type, Boolean):
+            for super_type in set_super_types:
+                if super_type in refinements.keys():
+                    refinements[super_type].add(key_type)
+                else:
+                    refinements[super_type] = {key_type}
+                rules_typeset += Typeset({key_type})
+                rules_typeset += Typeset(set_super_types)
+    for super, refined in refinements.items():
+        rules_str.append(g_(iff_(super.name, or_([r.name for r in refined]))))
+
+    if output_list:
+        return rules_str, rules_typeset
+
+    if len(rules_str) == 0:
+        return LTL("TRUE")
+
+    return LTL(
+        _init_formula=and_(rules_str, brackets=True),
+        _typeset=rules_typeset,
+        _kind=Specification.Kind.Rule.REFINEMENT,
+    )
+
+
+def extract_refinement_rules_legacy(
+        typeset: Typeset,
+        output_list: bool = False,
 ) -> LTL | tuple[list[str], Typeset]:
     """Extract Refinement rules from the Formula."""
 
@@ -29,7 +65,6 @@
                 rules_typeset += Typeset({key_type})
                 rules_typeset += Typeset(set_super_types)
 
-
     if output_list:
         return rules_str, rules_typeset
 
@@ -44,8 +79,8 @@
 
 
 def extract_mutex_rules(
-    typeset: Typeset,
-    output_list: bool = False,
+        typeset: Typeset,
+        output_list: bool = False,
 ) -> LTL | tuple[list[str], Typeset]:
     """Extract Mutex rules from the Formula."""
 
@@ -80,8 +115,8 @@
 
 
 def extract_adjacency_rules(
-    typeset: Typeset,
-    output_list: bool = False,
+        typeset: Typeset,
+        output_list: bool = False,
 ) -> LTL | tuple[list[str], Typeset]:
     """Extract Adjacency rules from the Formula."""
 
@@ -120,8 +155,8 @@
 
 
 def extract_liveness_rules(
-    typeset: Typeset,
-    output_list: bool = False,
+        typeset: Typeset,
+        output_list: bool = False,
 ) -> LTL | tuple[list[str], Typeset] | None:
     """Extract Liveness rules from the Formula."""
 
@@ -150,8 +185,8 @@
 
 
 def context_active_rules(
-    typeset: Typeset,
-    output_list: bool = False,
+        typeset: Typeset,
+        output_list: bool = False,
 ) -> LTL | tuple[list[str], Typeset] | None:
     """Extract Liveness rules from the Formula."""
 
Index: crome_logic/patterns/robotic_movement.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\n\nfrom dataclasses import dataclass, field\n\nfrom crome_logic.patterns import Pattern, PatternKind\nfrom crome_logic.tools.logic import Logic\n\n\n@dataclass\nclass CoreMovement(Pattern):\n    locations: list[str]\n\n    def __post_init__(self):\n        self.kind = PatternKind.ROBOTIC_MOVEMENT\n\n\n@dataclass\nclass Visit(CoreMovement):\n\n    def __post_init__(self):\n        self.name = \"Visit\"\n        self.description = \"Visit a set of location in an unspecified order\"\n        f = []\n        \"\"\"F(l1), F(l2), ...,F(ln)\"\"\"\n        for l in self.locations:\n            f.append(Logic.f_(l))\n        \"\"\"F(l1) & F(l2) & ... & F(ln)\"\"\"\n        new_formula = Logic.and_(f)\n        self.formula = new_formula\n\n\n@dataclass\nclass OrderedVisit(CoreMovement):\n    \"\"\"Given a set of locations the robot should visit all the locations.\"\"\"\n\n    def __post_init__(self):\n        self.name = \"Ordered Visit\"\n        self.description = \"The sequenced visit pattern does not forbid to visit a successor location before its \" \\\n                           \"predecessor, but only that after the predecessor is visited the successor is also \" \\\n                           \"visited. Ordered visit forbids a successor to be visited before its predecessor.\"\n        lor = list(self.locations)\n        lor.reverse()\n        n = len(self.locations)\n\n        f = []\n        \"\"\"F(l1), F(l2), ...,F(ln)\"\"\"\n        for l in self.locations:\n            f.append(Logic.f_(l))\n        \"\"\"F(l1) & F(l2) & ... & F(ln)\"\"\"\n        f1 = Logic.and_(f)\n\n        f2 = []\n        \"\"\"1..n-1   !l_{i+1} U l_{i}\"\"\"\n        for i, l in enumerate(self.locations[: n - 1]):\n            f = Logic.u_(Logic.not_(self.locations[i + 1]), self.locations[i])\n            f2.append(f)\n        f2 = Logic.and_(f2)\n\n        new_formula = Logic.and_([f1, f2])\n\n        self.formula = new_formula\n\n\n@dataclass\nclass StrictOrderedVisit(CoreMovement):\n\n    def __post_init__(self):\n        self.name = \"Strict Ordered Visit\"\n        self.description = \"The ordered visit pattern does not avoid a predecessor location to be visited multiple \" \\\n                           \"times before its successor. Strict ordered visit forbids the behavior.\"\n        lor = list(self.locations)\n        lor.reverse()\n        n = len(self.locations)\n\n        f = []\n        \"\"\"F(l1), F(l2), ...,F(ln)\"\"\"\n        for l in self.locations:\n            f.append(Logic.f_(l))\n        \"\"\"F(l1) & F(l2) & ... & F(ln)\"\"\"\n        f1 = Logic.and_(f)\n\n        f2 = []\n        \"\"\"1..n-1   !l_{i+1} U l_{i}\"\"\"\n        for i, l in enumerate(self.locations[: n - 1]):\n            f = Logic.u_(Logic.not_(self.locations[i + 1]), self.locations[i])\n            f2.append(f)\n        f2 = Logic.and_(f2)\n\n        f3 = []\n        \"\"\"1..n-1   !l_{i} U l_{i} & X(!l_{i} U l_{i+1})\"\"\"\n        for i, l in enumerate(self.locations[: n - 1]):\n            f = Logic.u_(\n                Logic.not_(self.locations[i]),\n                Logic.and_(\n                    [\n                        self.locations[i],\n                        Logic.x_(\n                            Logic.u_(\n                                Logic.not_(self.locations[i]), self.locations[i + 1]\n                            )\n                        ),\n                    ]\n                ),\n            )\n            f3.append(f)\n        f3 = Logic.and_(f3)\n\n        new_formula = Logic.and_([f1, f2, f3])\n\n        self.formula = new_formula\n\n\n@dataclass\nclass Patrolling(CoreMovement):\n\n    def __post_init__(self):\n        self.name = \"Patrolling\"\n        self.description = \"Keep visiting a set of locations, but not a particular order. The patrolling problem \" \\\n                           \"also appears in literature as surveillance.\"\n        f = []\n\n        for l in self.locations:\n            f.append(Logic.gf_(l))\n\n        self.formula = Logic.and_(f)\n\n\n@dataclass\nclass OrderedPatrolling(CoreMovement):\n\n    def __post_init__(self):\n        self.name = \"Ordered Patrolling\"\n        self.description = \"Sequence patrolling deos not forbid to visit a successor location before its predecessor. \" \\\n                           \"Ordered patrolling ensures that (after a successor is visited) the successor is not \" \\\n                           \"visited (again) before its predecessor.\"\n        lor = list(self.locations)\n        lor.reverse()\n        n = len(self.locations)\n\n        f1 = Logic.f_(lor[0])\n\n        if len(self.locations) == 1:\n            self.formula = Logic.g_(f1)\n            return\n        \"\"\"GF(l1 & F(l2 & ... F(ln))))\"\"\"\n        for l in lor[1:]:\n            f2 = Logic.and_([l, f1])\n            f1 = Logic.f_(f2)\n        f1 = Logic.g_(f1)\n\n        f2 = []\n        \"\"\"1..n-1   !l_{i+1} U l_{i}\"\"\"\n        for i, l in enumerate(self.locations[: n - 1]):\n            f = Logic.u_(Logic.not_(self.locations[i + 1]), self.locations[i])\n            f2.append(f)\n        f2 = Logic.and_(f2)\n\n        f3 = []\n        \"\"\"1..n   G(l_{(i+1)%n} -> X((!l_{(i+1)%n} U l_{i})))\"\"\"\n        for i, l in enumerate(self.locations):\n            f = Logic.g_(\n                Logic.implies_(\n                    self.locations[(i + 1) % n],\n                    Logic.x_(\n                        Logic.u_(\n                            Logic.not_(self.locations[(i + 1) % n]), self.locations[i]\n                        )\n                    ),\n                )\n            )\n            f3.append(f)\n        f3 = Logic.and_(f3)\n\n        new_formula = Logic.and_([f1, f2, f3])\n\n        self.formula = new_formula\n\n\n@dataclass\nclass StrictOrderedPatrolling(CoreMovement):\n\n    def __post_init__(self):\n        self.name = \"Strict Ordered Patrolling\"\n        self.description = \"The ordered patrolling does not avoid a predecessor location to be visited multiple \" \\\n                           \"times before its successor. Strict Ordered Patrolling ensures that, after a predecessor \" \\\n                           \"is visited, it is not visited again before its successor. \"\n        lor = list(self.locations)\n        lor.reverse()\n        n = len(self.locations)\n\n        f1 = Logic.f_(lor[0])\n\n        if len(self.locations) == 1:\n            self.formula = Logic.g_(f1)\n            return\n        \"\"\"GF(l1 & F(l2 & ... F(ln))))\"\"\"\n        for l in lor[1:]:\n            f2 = Logic.and_([l, f1])\n            f1 = Logic.f_(f2)\n        f1 = Logic.g_(f1)\n\n        f2 = []\n        \"\"\"1..n-1   !l_{i+1} U l_{i}\"\"\"\n        for i, l in enumerate(self.locations[: n - 1]):\n            f = Logic.u_(Logic.not_(self.locations[i + 1]), self.locations[i])\n            f2.append(f)\n        f2 = Logic.and_(f2)\n\n        f3 = []\n        \"\"\"1..n   G(l_{(i+1)%n} -> X((!l_{(i+1)%n} U l_{i})))\"\"\"\n        for i, l in enumerate(self.locations):\n            f = Logic.g_(\n                Logic.implies_(\n                    self.locations[(i + 1) % n],\n                    Logic.x_(\n                        Logic.u_(\n                            Logic.not_(self.locations[(i + 1) % n]), self.locations[i]\n                        )\n                    ),\n                )\n            )\n            f3.append(f)\n        f3 = Logic.and_(f3)\n\n        if len(self.locations) > 2:\n            f4 = []\n            \"\"\"1..n   G(l_{(i+1)%n} -> X((!l_{(i+1)%n} U l_{i})))\"\"\"\n            for i, l in enumerate(self.locations):\n                f = Logic.g_(\n                    Logic.implies_(\n                        self.locations[i],\n                        Logic.x_(\n                            Logic.u_(\n                                Logic.not_(self.locations[i]),\n                                self.locations[(i + 1) % n],\n                            )\n                        ),\n                    )\n                )\n                f4.append(f)\n            f4 = Logic.and_(f4)\n            new_formula = Logic.and_([f1, f2, f3, f4])\n        else:\n            new_formula = Logic.and_([f1, f2, f3])\n\n        self.formula = new_formula\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crome_logic/patterns/robotic_movement.py b/crome_logic/patterns/robotic_movement.py
--- a/crome_logic/patterns/robotic_movement.py	(revision bb18496a6cc3a638dab82652523c81472eccf5fb)
+++ b/crome_logic/patterns/robotic_movement.py	(date 1655334209829)
@@ -1,6 +1,6 @@
 from __future__ import annotations
 
-from dataclasses import dataclass, field
+from dataclasses import dataclass
 
 from crome_logic.patterns import Pattern, PatternKind
 from crome_logic.tools.logic import Logic
@@ -244,3 +244,145 @@
             new_formula = Logic.and_([f1, f2, f3])
 
         self.formula = new_formula
+
+
+@dataclass
+class StrictOrderedLocations(CoreMovement):
+
+    def __post_init__(self):
+        self.name = "Strict Order"
+        self.description = "Modification of StrictOrderedPatrolling, it impose the order but not the actual visit." \
+                           "The ordered patrolling does not avoid a predecessor location to be visited multiple " \
+                           "times before its successor. Strict Ordered Patrolling ensures that, after a predecessor " \
+                           "is visited, it is not visited again before its successor. "
+        lor = list(self.locations)
+        lor.reverse()
+        n = len(self.locations)
+
+        # f1 = Logic.f_(lor[0])
+        #
+        # if len(self.locations) == 1:
+        #     self.formula = Logic.g_(f1)
+        #     return
+        # """GF(l1 & F(l2 & ... F(ln))))"""
+        # for l in lor[1:]:
+        #     f2 = Logic.and_([l, f1])
+        #     f1 = Logic.f_(f2)
+        # f1 = Logic.g_(f1)
+
+        f2 = []
+        """1..n-1   !l_{i+1} U l_{i}"""
+        for i, l in enumerate(self.locations[: n - 1]):
+            f = Logic.u_(Logic.not_(self.locations[i + 1]), self.locations[i])
+            f2.append(f)
+        f2 = Logic.and_(f2)
+
+        f3 = []
+        """1..n   G(l_{(i+1)%n} -> X((!l_{(i+1)%n} U l_{i})))"""
+        for i, l in enumerate(self.locations):
+            f = Logic.g_(
+                Logic.implies_(
+                    self.locations[(i + 1) % n],
+                    Logic.x_(
+                        Logic.u_(
+                            Logic.not_(self.locations[(i + 1) % n]), self.locations[i]
+                        )
+                    ),
+                )
+            )
+            f3.append(f)
+        f3 = Logic.and_(f3)
+
+        if len(self.locations) > 2:
+            f4 = []
+            """1..n   G(l_{(i+1)%n} -> X((!l_{(i+1)%n} U l_{i})))"""
+            for i, l in enumerate(self.locations):
+                f = Logic.g_(
+                    Logic.implies_(
+                        self.locations[i],
+                        Logic.x_(
+                            Logic.u_(
+                                Logic.not_(self.locations[i]),
+                                self.locations[(i + 1) % n],
+                            )
+                        ),
+                    )
+                )
+                f4.append(f)
+            f4 = Logic.and_(f4)
+            new_formula = Logic.and_([f2, f3, f4])
+        else:
+            new_formula = Logic.and_([f2, f3])
+
+        self.formula = new_formula
+
+
+@dataclass
+class OrderedLocations(CoreMovement):
+
+    def __post_init__(self):
+        self.name = "Order Location"
+        self.description = "Modification of OrderedPatrolling, it impose the order but not the actual visit." \
+                           "The ordered patrolling does not avoid a predecessor location to be visited multiple " \
+                           "times before its successor. Strict Ordered Patrolling ensures that, after a predecessor " \
+                           "is visited, it is not visited again before its successor. "
+        lor = list(self.locations)
+        lor.reverse()
+        n = len(self.locations)
+
+        # f1 = Logic.f_(lor[0])
+        #
+        # if len(self.locations) == 1:
+        #     self.formula = Logic.g_(f1)
+        #     return
+        # """GF(l1 & F(l2 & ... F(ln))))"""
+        # for l in lor[1:]:
+        #     f2 = Logic.and_([l, f1])
+        #     f1 = Logic.f_(f2)
+        # f1 = Logic.g_(f1)
+
+        f2 = []
+        """1..n-1   !l_{i+1} U l_{i}"""
+        for i, l in enumerate(self.locations[: n - 1]):
+            f = Logic.u_(Logic.not_(self.locations[i + 1]), self.locations[i])
+            f2.append(f)
+        f2 = Logic.and_(f2)
+
+        f3 = []
+        """1..n   G(l_{(i+1)%n} -> X((!l_{(i+1)%n} U l_{i})))"""
+        for i, l in enumerate(self.locations):
+            f = Logic.g_(
+                Logic.implies_(
+                    self.locations[(i + 1) % n],
+                    Logic.x_(
+                        Logic.u_(
+                            Logic.not_(self.locations[(i + 1) % n]), self.locations[i]
+                        )
+                    ),
+                )
+            )
+            f3.append(f)
+        f3 = Logic.and_(f3)
+
+        if len(self.locations) > 2:
+            f4 = []
+            """1..n   G(l_{(i+1)%n} -> X((!l_{(i+1)%n} U l_{i})))"""
+            for i, l in enumerate(self.locations):
+                f = Logic.g_(
+                    Logic.implies_(
+                        self.locations[i],
+                        Logic.x_(
+                            Logic.u_(
+                                Logic.not_(self.locations[i]),
+                                self.locations[(i + 1) % n],
+                            )
+                        ),
+                    )
+                )
+                f4.append(f)
+            f4 = Logic.and_(f4)
+            new_formula = Logic.and_([f2, f3])
+        else:
+            new_formula = Logic.and_([f2, f3])
+
+        self.formula = new_formula
Index: crome_logic/specification/string_logic.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import re\nfrom typing import List\n\nOPERATORS = r\"\\+|-|\\*|==|<=|>=|<|>|!|\\||->|&\"\nTEMPORAL_OPS = r\"^F|^G|^X|^U\"\n\noperators = re.compile(OPERATORS)\ntemporal_ops = re.compile(TEMPORAL_OPS)\n\n\ndef general_logic(operation: str, elements: List[str]):\n    if operation == \"And\":\n        return and_(elements, brackets=True)\n    elif operation == \"Or\":\n        return or_(elements)\n    elif operation == \"Not\":\n        return not_(elements[0])\n    elif operation == \"Implies\":\n        return implies_(elements[0], elements[1])\n    else:\n        raise Exception(f\"Attribute unknown: {operation}\")\n\n\ndef and_(propositions: List[str], brackets: bool = False) -> str:\n    \"\"\"Returns an str formula representing the logical AND of\n    list_propoositions.\"\"\"\n    if len(propositions) > 1:\n\n        if \"FALSE\" in propositions:\n            return \"FALSE\"\n        \"\"\"Remove all TRUE elements\"\"\"\n        propositions = list(filter(\"TRUE\".__ne__, propositions))\n        if len(propositions) == 0:\n            return \"TRUE\"\n\n        conj = \" & \".join(propositions)\n        if brackets:\n            return f\"({conj})\"\n        else:\n            return conj\n\n    elif len(propositions) == 1:\n        return propositions[0]\n    else:\n        print(\"List of propositions is empty\")\n        return \"\"\n\n\ndef implies_(prop_1: str, prop_2: str) -> str:\n    \"\"\"Returns an str formula representing the logical IMPLIES of prop_1 and\n    prop_2.\"\"\"\n    if prop_1 == \"TRUE\" or prop_1 == \"(TRUE)\" or prop_1 == \"true\" or prop_1 == \"(true)\" or prop_1 == \"\":\n        return prop_2\n    return f\"(!({prop_1}) | ({prop_2}))\"\n    # return f\"(!({prop_1}) | ({prop_2}))\"\n\n\ndef iff_(prop_1: str, prop_2: str) -> str:\n    \"\"\"Returns an str formula representing the logical IFF of prop_1 and\n    prop_2.\"\"\"\n    if prop_1 == \"TRUE\" or prop_1 == \"(TRUE)\" or prop_1 == \"true\" or prop_1 == \"(true)\":\n        return prop_2\n    return f\"(({prop_1}) <-> ({prop_2}))\"\n\n\ndef not_(prop: str) -> str:\n    \"\"\"Returns an str formula representing the logical NOT of prop.\"\"\"\n    # match_operators = bool(re.search(operators, prop))\n    # match_temporal = bool(re.search(temporal_ops, prop))\n    # if match_operators or match_temporal:\n    #     return f\"!({prop})\"\n    if prop == \"TRUE\":\n        return \"FALSE\"\n    if prop == \"FALSE\":\n        return \"TRUE\"\n    return f\"!({prop})\"\n\n\ndef x_(prop: str) -> str:\n    \"\"\"Next.\"\"\"\n    return f\"X({prop})\"\n\n\ndef xn_(prop: str, n: int) -> str:\n    \"\"\"n times Next.\"\"\"\n    ret = \"\"\n    for i in range(n):\n        ret += \"X(\"\n    ret += prop\n    for i in range(n):\n        ret += \")\"\n    return ret\n\n\ndef f_(prop: str) -> str:\n    \"\"\"Eventually.\"\"\"\n    return f\"F({prop})\"\n\n\ndef g_(prop: str) -> str:\n    \"\"\"Globally.\"\"\"\n    return f\"G({prop})\"\n\n\ndef gf_(prop: str) -> str:\n    \"\"\"Globally Eventually.\"\"\"\n    return f\"G(F({prop}))\"\n\n\ndef u_(pre: str, post: str) -> str:\n    \"\"\"Until.\"\"\"\n    return f\"({pre} U {post})\"\n\n\ndef w_(pre: str, post: str) -> str:\n    \"\"\"Weak Until.\"\"\"\n    return or_([u_(pre, post), g_(pre)])\n\n\ndef or_(propositions: List[str], brackets=True) -> str:\n    \"\"\"Returns an formula formula representing the logical OR of\n    list_propoositions.\"\"\"\n    if len(propositions) > 1:\n        if \"TRUE\" in propositions:\n            return \"TRUE\"\n        \"\"\"Remove all FALSE elements\"\"\"\n        propositions = list(filter(\"FALSE\".__ne__, propositions))\n\n        res = \" | \".join(propositions)\n        if brackets:\n            return f\"({res})\"\n        else:\n            return f\"{res}\"\n    elif len(propositions) == 1:\n        return propositions[0]\n    else:\n        raise Exception(\"List of propositions is empty\")\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crome_logic/specification/string_logic.py b/crome_logic/specification/string_logic.py
--- a/crome_logic/specification/string_logic.py	(revision bb18496a6cc3a638dab82652523c81472eccf5fb)
+++ b/crome_logic/specification/string_logic.py	(date 1655173986141)
@@ -30,6 +30,8 @@
             return "FALSE"
         """Remove all TRUE elements"""
         propositions = list(filter("TRUE".__ne__, propositions))
+        """Remove all empty elements"""
+        propositions = list(filter("".__ne__, propositions))
         if len(propositions) == 0:
             return "TRUE"
 
@@ -125,6 +127,8 @@
             return "TRUE"
         """Remove all FALSE elements"""
         propositions = list(filter("FALSE".__ne__, propositions))
+        """Remove all empty elements"""
+        propositions = list(filter("".__ne__, propositions))
 
         res = " | ".join(propositions)
         if brackets:
Index: crome_logic/specification/temporal/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\n\nfrom copy import deepcopy\nfrom dataclasses import dataclass, fields\n\nimport spot\nfrom treelib import Tree\n\nfrom crome_logic.patterns import Pattern\nfrom crome_logic.specification import Cnf, Dnf, Specification\nfrom crome_logic.specification.boolean import Bool\nfrom crome_logic.specification.temporal.tools import transform_spot_tree\nfrom crome_logic.specification.tools import is_true_string\nfrom crome_logic.specification.trees import (\n    boolean_tree_to_formula,\n    extract_atoms_dictionary,\n    gen_atoms_tree,\n    gen_ltl_tree,\n)\nfrom crome_logic.tools.atomic_propositions import extract_ap\nfrom crome_logic.tools.nuxmv import check_satisfiability, check_validity\nfrom crome_logic.typelement.basic import Boolean\nfrom crome_logic.typelement.robotic import BooleanSensor, BooleanLocation\nfrom crome_logic.typeset import Typeset\n\n\n@dataclass(frozen=True)\nclass LTL(Specification):\n    _init_formula: str | Pattern\n    _typeset: Typeset | None = None\n    _boolean: Bool | None = None\n    _kind: Specification.Kind = Specification.Kind.UNDEFINED\n    _expression: spot.formula | None = None\n    _tree: Tree | None = None\n\n    @property\n    def boolean(self) -> Bool:\n        if isinstance(self._boolean, Bool):\n            return self._boolean\n        raise AttributeError\n\n    @property\n    def kind(self) -> Specification.Kind:\n        return self._kind\n\n    @property\n    def expression(self) -> spot.formula:\n        return self._expression\n\n    @property\n    def tree(self) -> Tree:\n        return self._tree\n\n    def __post_init__(self):\n        if isinstance(self._init_formula, Pattern):\n            object.__setattr__(self, \"_init_formula\", str(self._init_formula))\n        self._initialize_external_libraries_objects(self._init_formula)\n\n        if self._typeset is None:\n            set_ap_str = extract_ap(self.expression)\n            set_ap = set(map(lambda x: Boolean(name=x), set_ap_str))\n            typeset = Typeset(set_ap)\n        else:\n            typeset = self.typeset.get_sub_typeset(str(self.expression))\n        object.__setattr__(self, \"_typeset\", typeset)\n\n    def _initialize_external_libraries_objects(self, formula: str):\n        expression = transform_spot_tree(spot.formula(formula))\n        object.__setattr__(self, \"_expression\", expression)\n        if self._boolean is None:\n            atom_tree = gen_atoms_tree(spot_f=self.expression)\n            boolean = Bool(\n                _init_formula=boolean_tree_to_formula(atom_tree), _tree=atom_tree\n            )\n            object.__setattr__(self, \"_boolean\", boolean)\n        tree: Tree = gen_ltl_tree(spot_f=self.expression)\n        object.__setattr__(self, \"_tree\", tree)\n\n    @classmethod\n    def from_pattern(cls, formula: Pattern, typeset: Typeset | None = None) -> LTL:\n        return cls(_init_formula=str(formula), _typeset=typeset)\n\n    def __hash__(self: LTL):\n        return hash(str(self))\n\n    @property\n    def formula(self) -> str:\n        return str(self.expression)\n\n\n    @property\n    def typeset_complete(self) -> Typeset:\n        return self.typeset + self.refinement_rules.typeset + self.adjacency_and_mutex_rules.typeset\n\n    def __str__(self):\n        return self.formula\n\n    def __deepcopy__(self: LTL, memo):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        for field in fields(cls):\n            if not (\n                    field.name == \"_boolean\"\n                    or field.name == \"_expression\"\n                    or field.name == \"_tree\"\n            ):\n                object.__setattr__(\n                    result, field.name, deepcopy(getattr(self, field.name))\n                )\n        result._initialize_external_libraries_objects(result.init_formula)\n        return result\n\n    @property\n    def summary(self) -> str:\n        cnf_list = \"\\n\".join(self.cnf.to_str_list)\n        dnf_list = \"\\n\".join(self.dnf.to_str_list)\n        ret = (\n            f\"\\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\"\n            f\"LTL SIMPLIFIED\\n\"\n            f\"{str(self)}\\n\\n\"\n            f\"BOOLEAN REPRESENTATION\\n\"\n            f\"{str(self.boolean)}\\n\\n\"\n            f\"LTL CNF (from booleans)\\n\"\n            f\"{self.cnf.to_str}\\n\"\n            f\"LTL CNF (list)\\n\"\n            f\"{cnf_list}\\n\\n\"\n            f\"LTL DNF (from booleans)\\n\"\n            f\"{self.dnf.to_str}\\n\"\n            f\"LTL DNF (list)\\n\"\n            f\"{dnf_list}\\n\"\n            f\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\n\"\n        )\n        return ret\n\n    @property\n    def cnf(self) -> Cnf:\n        atoms_cnf = self.boolean.cnf.clauses\n        cnf_list = []\n        atoms_dictionary = extract_atoms_dictionary(self.boolean.tree)\n        for clauses in atoms_cnf:\n            atoms = set()\n            for atom in clauses:\n                atom_str: str = str(atom)\n                if atom_str.startswith(\"!\"):\n                    ltl_formula = f\"!{atoms_dictionary[atom_str[1:]]}\"\n                else:\n                    ltl_formula = atoms_dictionary[str(atom)]\n                ltl_object = LTL(\n                    _init_formula=ltl_formula,\n                    _typeset=self.typeset.get_sub_typeset(ltl_formula),\n                )\n                atoms.add(ltl_object)\n            cnf_list.append(atoms)\n        return Cnf(cnf_list)  # type: ignore\n\n    @property\n    def dnf(self) -> Dnf:\n        atoms_dnf = self.boolean.dnf.clauses\n        dnf_list = []\n        atoms_dictionary = extract_atoms_dictionary(self.boolean.tree)\n        for clauses in atoms_dnf:\n            atoms = set()\n            for atom in clauses:\n                atom_str: str = str(atom)\n                if atom_str.startswith(\"!\"):\n                    ltl_formula = f\"!{atoms_dictionary[atom_str[1:]]}\"\n                else:\n                    ltl_formula = atoms_dictionary[str(atom)]\n                ltl_object = LTL(\n                    _init_formula=ltl_formula,\n                    _typeset=self.typeset.get_sub_typeset(ltl_formula),\n                )\n                atoms.add(ltl_object)\n            dnf_list.append(atoms)\n        return Dnf(dnf_list)  # type: ignore\n\n    def export_to_json(self):\n        json_content = {}\n        if self.formula == \"1\":\n            json_content = {\"ltl_value\": \"true\",\n                            \"world_values\": [[], [], []]}\n        else:\n            sensor = []\n            location = []\n            action = []\n            typeset = self.typeset\n            for keyType in typeset:\n                if type(typeset[keyType]) == BooleanSensor:\n                    sensor.append(keyType)\n                elif type(typeset[keyType]) == BooleanLocation:\n                    location.append(keyType)\n                else:\n                    action.append(keyType)\n            json_content = {\"ltl_value\": self.formula,\n                            \"world_values\": [sensor, action, location]}\n        return json_content\n\n    def __iand__(self: Specification, other: Specification) -> LTL:\n        \"\"\"self &= other Modifies self with the conjunction with other.\"\"\"\n        if not (isinstance(self, LTL) and isinstance(other, LTL)):\n            raise AttributeError\n        if self.is_true_expression:\n            init_formula = deepcopy(other.formula)\n            typeset = deepcopy(other.typeset)\n            boolean = deepcopy(other.boolean)\n            object.__setattr__(self, \"_init_formula\", init_formula)\n            object.__setattr__(self, \"_typeset\", typeset)\n            object.__setattr__(self, \"_boolean\", boolean)\n\n            self.__post_init__()  # type: ignore\n\n            return self\n\n        if other.is_true_expression:\n            return self\n\n        init_formula = f\"({str(self)}) & ({str(other)})\"\n        typeset = self.typeset + other.typeset\n        boolean = self.boolean & other.boolean\n\n        object.__setattr__(self, \"_init_formula\", init_formula)\n        object.__setattr__(self, \"_typeset\", typeset)\n        object.__setattr__(self, \"_boolean\", boolean)\n\n        self.__post_init__()  # type: ignore\n\n        return self\n\n    def __ior__(self: Specification, other: Specification) -> LTL:\n        \"\"\"self |= other Modifies self with the disjunction with other.\"\"\"\n        if not (isinstance(self, LTL) and isinstance(other, LTL)):\n            raise AttributeError\n        if self.is_true_expression or other.is_true_expression:\n            init_formula = f\"TRUE\"\n        else:\n            init_formula = f\"({str(self)}) | ({str(other)})\"\n\n        typeset = self.typeset + other.typeset\n        boolean = self.boolean | other.boolean\n        object.__setattr__(self, \"_init_formula\", init_formula)\n        object.__setattr__(self, \"_typeset\", typeset)\n        object.__setattr__(self, \"_boolean\", boolean)\n\n        self.__post_init__()  # type: ignore\n\n        return self\n\n    def __and__(self: Specification, other: Specification) -> LTL:\n        \"\"\"self & other Returns a new LTL with the conjunction with other.\"\"\"\n        if not (isinstance(self, LTL) and isinstance(other, LTL)):\n            raise AttributeError\n        if self.is_true_expression:\n            return LTL(\n                _init_formula=str(other),\n                _boolean=other.boolean,\n                _typeset=other.typeset,\n            )\n\n        if other.is_true_expression:\n            return LTL(\n                _init_formula=str(self),\n                _boolean=self.boolean,\n                _typeset=self.typeset,\n            )\n\n        return LTL(\n            _init_formula=f\"({str(self)}) & ({str(other)})\",\n            _boolean=self.boolean & other.boolean,\n            _typeset=self.typeset + other.typeset,\n        )\n\n    def __or__(self: Specification, other: Specification) -> LTL:\n        \"\"\"self | other Returns a new LTL with the disjunction with other.\"\"\"\n        if not (isinstance(self, LTL) and isinstance(other, LTL)):\n            raise AttributeError\n        if self.is_true_expression or other.is_true_expression:\n            return LTL(\"TRUE\")\n\n        return LTL(\n            _init_formula=f\"({str(self)}) | ({str(other)})\",\n            _boolean=self.boolean | other.boolean,\n            _typeset=self.typeset + other.typeset,\n        )\n\n    def __invert__(self: Specification) -> LTL:\n        \"\"\"Returns a new LTL with the negation of self.\"\"\"\n        if not isinstance(self, LTL):\n            raise AttributeError\n        return LTL(\n            _init_formula=f\"!({self.expression})\",\n            _boolean=~self.boolean,\n            _typeset=self.typeset,\n        )\n\n    def __rshift__(self: Specification, other: Specification) -> LTL:\n        \"\"\">> Returns a new LTL that is the result of self -> other\n        (implies)\"\"\"\n        if not (isinstance(self, LTL) and isinstance(other, LTL)):\n            raise AttributeError\n        if self.is_true_expression:\n            return LTL(\n                _init_formula=str(other),\n                _boolean=other.boolean,\n                _typeset=other.typeset,\n            )\n\n        return LTL(\n            _init_formula=f\"({self.expression}) -> ({other.expression})\",\n            _boolean=self.boolean >> other.boolean,\n            _typeset=self.typeset + other.typeset,\n        )\n\n    @property\n    def adjacency_and_mutex_rules(self) -> LTL:\n        from crome_logic.specification.rules_extractors import (\n            extract_adjacency_rules, extract_mutex_rules\n        )\n\n        return extract_mutex_rules(self.typeset) & extract_adjacency_rules(self.typeset)\n\n    @property\n    def refinement_rules(self) -> LTL:\n        from crome_logic.specification.rules_extractors import (\n            extract_refinement_rules\n        )\n\n        return extract_refinement_rules(self.typeset)\n\n    @property\n    def is_satisfiable(self: LTL) -> bool:\n\n        new_f = self & self.adjacency_and_mutex_rules\n\n        return check_satisfiability(str(new_f), new_f.typeset.to_str_nuxmv())\n\n    @property\n    def is_valid(self: LTL) -> bool:\n\n        if isinstance(self.kind, LTL.Kind.Rule):\n            return check_validity(str(self), self.typeset.to_str_nuxmv())\n\n        new_f = self.refinement_rules >> self\n\n        return check_validity(str(new_f), new_f.typeset.to_str_nuxmv())\n\n    @property\n    def is_true_expression(self) -> bool:\n        if is_true_string(str(self)):\n            return True\n\n    def __lt__(self, other: LTL):\n        \"\"\"self < other.\n\n        True if self is a refinement but not equal to other\n        \"\"\"\n        return self.__le__(other) and self.__ne__(other)\n\n    def __le__(self: LTL, other: LTL):\n        \"\"\"self <= other.\n\n        True if self is a refinement of other\n        \"\"\"\n        \"\"\"Check if (self -> other) is valid\"\"\"\n        return (self >> other).is_valid\n\n    def __gt__(self, other: LTL):\n        \"\"\"self > other.\n\n        True if self is an abstraction but not equal to other\n        \"\"\"\n        return self.__ge__(other) and self.__ne__(other)\n\n    def __ge__(self, other: LTL):\n        \"\"\"self >= other.\n\n        True if self is an abstraction of other\n        \"\"\"\n        \"\"\"Check if (other -> self) is valid\"\"\"\n        return (other >> self).is_valid\n\n    def __eq__(self, other: object):\n        \"\"\"Check if self == other.\"\"\"\n        if not isinstance(other, LTL):\n            return NotImplemented\n        if str(self) == str(other):\n            return True\n        else:\n            not_self = ~self\n            if str(not_self) == str(other):\n                return False\n            return self.__le__(other) and self.__ge__(other)\n\n    def __ne__(self, other: object):\n        \"\"\"Check if self != other.\"\"\"\n        if not isinstance(other, LTL):\n            return NotImplemented\n        return not self.__eq__(other)\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        del state[\"_tree\"]\n        state[\"_expression\"] = str(self.expression)\n        state[\"_boolean\"] = str(self.boolean)\n        state[\"_boolean_typeset\"] = self.boolean.typeset\n\n        return state\n\n    def __setstate__(self, state):\n        expression = state[\"_expression\"]\n        boolean = state[\"_boolean\"]\n        boolean_typeset = state[\"_boolean_typeset\"]\n        del state[\"_expression\"]\n        del state[\"_boolean\"]\n        del state[\"_boolean_typeset\"]\n        self.__dict__.update(state)\n        init_formula = expression\n        boolean = Bool(_init_formula=boolean, _typeset=boolean_typeset)\n        object.__setattr__(self, \"_init_formula\", init_formula)\n        object.__setattr__(self, \"_boolean\", boolean)\n        self.__post_init__()  # type: ignore\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crome_logic/specification/temporal/__init__.py b/crome_logic/specification/temporal/__init__.py
--- a/crome_logic/specification/temporal/__init__.py	(revision bb18496a6cc3a638dab82652523c81472eccf5fb)
+++ b/crome_logic/specification/temporal/__init__.py	(date 1655343119163)
@@ -19,7 +19,7 @@
 )
 from crome_logic.tools.atomic_propositions import extract_ap
 from crome_logic.tools.nuxmv import check_satisfiability, check_validity
-from crome_logic.typelement.basic import Boolean
+from crome_logic.typelement.basic import Boolean, BooleanUncontrollable, BooleanControllable
 from crome_logic.typelement.robotic import BooleanSensor, BooleanLocation
 from crome_logic.typeset import Typeset
 
@@ -32,6 +32,7 @@
     _kind: Specification.Kind = Specification.Kind.UNDEFINED
     _expression: spot.formula | None = None
     _tree: Tree | None = None
+    _parse_env_systems: bool = False
 
     @property
     def boolean(self) -> Bool:
@@ -58,10 +59,19 @@
 
         if self._typeset is None:
             set_ap_str = extract_ap(self.expression)
-            set_ap = set(map(lambda x: Boolean(name=x), set_ap_str))
-            typeset = Typeset(set_ap)
+            if self._parse_env_systems:
+                set_ap_str_s = list(filter(lambda x: x.startswith('s'), set_ap_str))
+                set_ap_str_e = list(filter(lambda x: x.startswith('e'), set_ap_str))
+                set_ap_s = set(map(lambda x: BooleanControllable(name=x), set_ap_str_s))
+                set_ap_e = set(map(lambda x: BooleanUncontrollable(name=x), set_ap_str_e))
+                typeset = Typeset(set_ap_s | set_ap_e)
+            else:
+                set_ap = set(map(lambda x: Boolean(name=x), set_ap_str))
+                typeset = Typeset(set_ap)
         else:
-            typeset = self.typeset.get_sub_typeset(str(self.expression))
+            # typeset = self.typeset.get_sub_typeset(str(self.expression))
+            typeset = self._typeset
+            # TODO: introduce the world
         object.__setattr__(self, "_typeset", typeset)
 
     def _initialize_external_libraries_objects(self, formula: str):
@@ -87,7 +97,6 @@
     def formula(self) -> str:
         return str(self.expression)
 
-
     @property
     def typeset_complete(self) -> Typeset:
         return self.typeset + self.refinement_rules.typeset + self.adjacency_and_mutex_rules.typeset
@@ -312,11 +321,23 @@
 
     @property
     def adjacency_and_mutex_rules(self) -> LTL:
+        return self.adjacency_rules & self.mutex_rules
+
+    @property
+    def adjacency_rules(self) -> LTL:
+        from crome_logic.specification.rules_extractors import (
+            extract_adjacency_rules
+        )
+
+        return extract_adjacency_rules(self.typeset)
+
+    @property
+    def mutex_rules(self) -> LTL:
         from crome_logic.specification.rules_extractors import (
-            extract_adjacency_rules, extract_mutex_rules
+            extract_mutex_rules
         )
 
-        return extract_mutex_rules(self.typeset) & extract_adjacency_rules(self.typeset)
+        return extract_mutex_rules(self.typeset)
 
     @property
     def refinement_rules(self) -> LTL:
@@ -328,8 +349,17 @@
 
     @property
     def is_satisfiable(self: LTL) -> bool:
+        # print("CHECKSATNOW")
+        # print(self)
+        #
+        # adj = self.adjacency_rules
+        # print(adj)
+        #
+        # mtx = self.mutex_rules
+        # # print(mtx)
 
         new_f = self & self.adjacency_and_mutex_rules
+        # print(new_f)
 
         return check_satisfiability(str(new_f), new_f.typeset.to_str_nuxmv())
 
@@ -339,7 +369,14 @@
         if isinstance(self.kind, LTL.Kind.Rule):
             return check_validity(str(self), self.typeset.to_str_nuxmv())
 
-        new_f = self.refinement_rules >> self
+        # print(f"EXT:\n{self.refinement_rules}")
+        # print(f"ADJ:\n{self.adjacency_rules}")
+        # print(f"MTX:\n{self.mutex_rules}")
+        # print(f"VAL:\n{self}")
+        #
+        # new_f = (self.refinement_rules & self.adjacency_and_mutex_rules) >> self
+
+        new_f = self
 
         return check_validity(str(new_f), new_f.typeset.to_str_nuxmv())
 
@@ -361,7 +398,55 @@
         True if self is a refinement of other
         """
         """Check if (self -> other) is valid"""
-        return (self >> other).is_valid
+
+        # print(f"REFCHECK\n{str(self)}\n{str(other)}")
+        if not self.is_satisfiable:
+            return False
+        if not other.is_satisfiable:
+            return False
+
+        s = self
+        s_r = self.refinement_rules
+        s_a = self.adjacency_rules
+        s_m = self.mutex_rules
+        o = other
+        o_r = other.refinement_rules
+        o_a = other.adjacency_rules
+        o_m = other.mutex_rules
+        #
+        # print(f"sPHI:\n{s}")
+        # print(f"sEXT:\n{s_r}")
+        # print(f"sADJ:\n{s_a}")
+        # print(f"sMTX:\n{s_m}")
+        # print(f"oPHI:\n{o}")
+        # print(f"oEXT:\n{o_r}")
+        # print(f"oADJ:\n{o_a}")
+        # print(f"oMTX:\n{o_m}")
+
+        # new_f = (s_r & s_a & s_m & s) >> o
+        # new_f = (s_r & s_a & s_m & s) >> (o_r & o_a & o_m & o)
+        # new_f = (s_r & s_a & s_m & o_m & o_a & o_r) >> s >> o
+
+        # new_f = (s_r & s_a & s_m & o_m & o_a & o_r & s) >> o
+        # new_f = (s_r & s_a & s_m & o_m & o_a & s) >> o
+        new_f = (s_r & s_a & s_m & s) >> o
+
+
+
+        # new_f = (s_r & s_a & s_m & o_m & o_a & o_r & s) >> o
+        # new_f = (s_r & s_a & s_m & s) >> o
+        # new_f = (s_r & s_a & s_m & s) >> o
+
+        # new_f = s_r >> s >> o
+        # new_f = (((s_r & s_m) & (o_r & o_m) & s) >> o)
+
+        # new_f = ((s_r & s_m & s) >> o)
+        #
+        # new_f = (((s_r & s_m) >> s) >> ((s_r & s_m) >> o))
+
+        # new_f = (self.refinement_rules & self.adjacency_and_mutex_rules) >> other
+
+        return new_f.is_valid
 
     def __gt__(self, other: LTL):
         """self > other.
Index: crome_logic/patterns/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\n\nfrom dataclasses import dataclass, field\nfrom enum import Enum, auto\n\n\nclass PatternKind(Enum):\n    ROBOTIC_MOVEMENT = auto()\n    ROBOTIC_TRIGGER = auto()\n    DWYER = auto()\n    BASIC = auto()\n    UNKNOWN = auto()\n\n\n@dataclass\nclass Pattern:\n    formula: str = field(init=False, default=\"\")\n    name: str = field(init=False, default=\"\")\n    description: str = field(init=False, default=\"\")\n    kind: PatternKind = field(init=False, default=PatternKind.UNKNOWN)\n\n    def __str__(self):\n        return str(self.formula)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crome_logic/patterns/__init__.py b/crome_logic/patterns/__init__.py
--- a/crome_logic/patterns/__init__.py	(revision bb18496a6cc3a638dab82652523c81472eccf5fb)
+++ b/crome_logic/patterns/__init__.py	(date 1655173529551)
@@ -1,8 +1,11 @@
 from __future__ import annotations
 
+from copy import deepcopy
 from dataclasses import dataclass, field
 from enum import Enum, auto
 
+from crome_logic.specification import and_
+
 
 class PatternKind(Enum):
     ROBOTIC_MOVEMENT = auto()
@@ -21,3 +24,17 @@
 
     def __str__(self):
         return str(self.formula)
+
+    def __iand__(self, other: Pattern):
+        if isinstance(other, Pattern):
+            self.formula = and_([self.formula, other.formula])
+            return self
+        else:
+            raise AttributeError
+
+    def __and__(self, other: Pattern):
+        if isinstance(other, Pattern):
+            new = deepcopy(self)
+            return new.__iand__(other)
+        else:
+            raise AttributeError
\ No newline at end of file
Index: crome_logic/tools/nuxmv.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># type: ignore\nimport os\nimport subprocess\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import List\n\nfrom bloom_filter import BloomFilter\n\nimport docker\nfrom crome_logic.specification.string_logic import not_\nfrom crome_logic.specification.tools import is_false_string, is_true_string\nfrom crome_logic.tools.string_manipulation import add_spaces_spot_ltl\n\nbloom_sat_yes: BloomFilter = BloomFilter(max_elements=10000, error_rate=0.1)\nbloom_val_yes: BloomFilter = BloomFilter(max_elements=10000, error_rate=0.1)\nbloom_val_no: BloomFilter = BloomFilter(max_elements=10000, error_rate=0.1)\nbloom_sat_no: BloomFilter = BloomFilter(max_elements=10000, error_rate=0.1)\n\n\nclass CheckType(Enum):\n    SATISFIABILITY = 0\n    VALIDITY = 1\n\n\noutput_folder = os.path.abspath(\n    os.path.join(os.path.dirname(__file__), \"..\", \"..\", \"output\")\n)\nnusmvfilename = \"nusmvfile.smv\"\noutput_file = f\"{output_folder}/{nusmvfilename}\"\n\nif not os.path.exists(output_folder):\n    os.makedirs(output_folder)\n\nfolder_path = Path(output_folder)\nfile_path = Path(output_file)\n\n\ndef check_satisfiability(expression: str, aps: list[str]) -> bool:\n    if is_true_string(expression):\n        return True\n\n    if is_false_string(expression):\n        return False\n\n    if expression in bloom_sat_yes:\n        print(\"\\t\\t\\tSAT-SKIPPED:\\t\" + expression)\n        return True\n\n    if expression in bloom_sat_no:\n        print(\"\\t\\t\\tSAT-SKIPPED:\\t\" + expression)\n        return False\n\n    _write_file(aps, expression, CheckType.SATISFIABILITY)\n\n    print(f\"\\t\\t\\tChecking SAT:\\t\\t{expression}\")\n    output = _launch_nuxmv()\n\n\n    sat = _parse_output(output, CheckType.SATISFIABILITY)\n\n    if sat:\n        bloom_sat_yes.add(expression)\n    else:\n        bloom_sat_no.add(expression)\n\n    return sat\n\n\ndef check_validity(expression: str, aps: list[str]) -> bool:\n    if is_true_string(expression):\n        return True\n\n    if is_false_string(expression):\n        return False\n\n    if expression in bloom_val_yes:\n        print(\"\\t\\t\\tVAL-SKIPPED:\\t\" + expression)\n        return True\n\n    if expression in bloom_val_no:\n        print(\"\\t\\t\\tVAL-SKIPPED:\\t\" + expression)\n        return False\n\n    _write_file(aps, expression, CheckType.VALIDITY)\n\n    print(f\"\\t\\t\\tChecking VAL:\\t\\t{expression}\")\n    output = _launch_nuxmv()\n\n    valid = _parse_output(output, CheckType.VALIDITY)\n\n    if valid:\n        bloom_val_yes.add(expression)\n    else:\n        bloom_val_no.add(expression)\n\n    return valid\n\n\ndef _write_file(variables: List[str], expression: str, check_type: CheckType):\n    expression = add_spaces_spot_ltl(expression)\n    with open(file_path, \"w\") as ofile:\n        ofile.write(\"MODULE main\\n\")\n        ofile.write(\"VAR\\n\")\n        for v in list(set(variables)):\n            ofile.write(f\"\\t{v};\\n\")\n        ofile.write(\"\\n\")\n        ofile.write(\"LTLSPEC \")\n        if check_type == CheckType.SATISFIABILITY:\n            ofile.write(str(not_(expression)))\n        elif check_type == CheckType.VALIDITY:\n            ofile.write(str(expression))\n        else:\n            raise Exception(\"Type of checking not supported\")\n        ofile.write(\"\\n\")\n\n\ndef _parse_output(output: List[str], check_type: CheckType) -> bool:\n    for line in output:\n        if line[:16] == \"-- specification\":\n            spec = line[16:].partition(\"is\")[0]\n            if \"is false\" in line:\n                if check_type == CheckType.SATISFIABILITY:\n                    print(\"\\t\\t\\tSAT-YES:\\t\" + spec)\n                    return True\n                elif check_type == CheckType.VALIDITY:\n                    print(\"\\t\\t\\tVAL-NO :\\t\" + spec)\n                    return False\n                else:\n                    raise Exception(\"Type of checking not supported\")\n            elif \"is true\" in line:\n                if check_type == CheckType.SATISFIABILITY:\n                    print(\"\\t\\t\\tSAT-NO :\\t\" + spec)\n                    return False\n                elif check_type == CheckType.VALIDITY:\n                    print(\"\\t\\t\\tVAL-YES:\\t\" + spec)\n                    return True\n                else:\n                    raise Exception(\"Type of checking not supported\")\n            else:\n                raise Exception(\"nuXmv produced something unexpected\")\n\n\ndef _launch_nuxmv() -> List[str]:\n    # print(\"Launching nuXmv....\")\n    try:\n        \"\"\" \"Trying nuXmv locally.\"\"\"\n        output = subprocess.check_output(\n            [\"nuXmv\", file_path], encoding=\"UTF-8\", stderr=subprocess.DEVNULL\n        ).splitlines()\n\n    except Exception:\n        \"\"\" \"Trying nuXmv with docker.\"\"\"\n        docker_image = \"pmallozzi/ltltools\"\n        client = docker.from_env()\n        output = str(\n            client.containers.run(\n                image=docker_image,\n                volumes={f\"{folder_path}\": {\"bind\": \"/home/\", \"mode\": \"rw\"}},\n                command=f\"nuXmv /home/{nusmvfilename}\",\n                remove=True,\n            )\n        ).split(\"\\\\n\")\n\n    output = [\n        x for x in output if not (x[:3] == \"***\" or x[:7] == \"WARNING\" or x == \"\")\n    ]\n    # print(\"nuXmv has terminated!\")\n    return output\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crome_logic/tools/nuxmv.py b/crome_logic/tools/nuxmv.py
--- a/crome_logic/tools/nuxmv.py	(revision bb18496a6cc3a638dab82652523c81472eccf5fb)
+++ b/crome_logic/tools/nuxmv.py	(date 1655330051740)
@@ -44,11 +44,11 @@
         return False
 
     if expression in bloom_sat_yes:
-        print("\t\t\tSAT-SKIPPED:\t" + expression)
+        print("\t\t\tSAT-SKIPPED (YES):\t" + expression)
         return True
 
     if expression in bloom_sat_no:
-        print("\t\t\tSAT-SKIPPED:\t" + expression)
+        print("\t\t\tSAT-SKIPPED (NO):\t" + expression)
         return False
 
     _write_file(aps, expression, CheckType.SATISFIABILITY)
@@ -74,17 +74,18 @@
     if is_false_string(expression):
         return False
 
+    print(f"\t\t\tChecking VAL:\t\t{expression}")
+
     if expression in bloom_val_yes:
-        print("\t\t\tVAL-SKIPPED:\t" + expression)
+        print("\t\t\tVAL-SKIPPED (YES):\t" + expression)
         return True
 
     if expression in bloom_val_no:
-        print("\t\t\tVAL-SKIPPED:\t" + expression)
+        print("\t\t\tVAL-SKIPPED (NO):\t" + expression)
         return False
 
     _write_file(aps, expression, CheckType.VALIDITY)
 
-    print(f"\t\t\tChecking VAL:\t\t{expression}")
     output = _launch_nuxmv()
 
     valid = _parse_output(output, CheckType.VALIDITY)
Index: crome_logic/typelement/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\n\nfrom dataclasses import dataclass, field\nfrom enum import Enum, auto\nfrom typing import TypeVar\n\n\nclass TypeKind(Enum):\n    \"\"\"Kinds of CromeType.\"\"\"\n\n    UNKNOWN = auto()\n    SENSOR = auto()\n    LOCATION = auto()\n    ACTION = auto()\n    ACTIVE = auto()\n    CONTEXT = auto()\n    SENSOR_LOCATION = auto()\n    SENSOR_ACTION = auto()\n\n\n@dataclass(kw_only=True)\nclass CromeType:\n    \"\"\"Base class fo the types of CROME.\"\"\"\n\n    name: str\n    description: str = \"\"\n    kind: TypeKind = TypeKind.UNKNOWN\n    refinement_of: set[str] = field(default_factory=set)\n\n    controllable: bool = field(init=False, default=False)\n\n    def __str__(self):\n        return self.name\n\n    def __le__(self, other: CromeType):\n        if other.name in self.refinement_of:\n            return True\n        return other.name in self.refinement_of\n\n    def __eq__(self, other):\n        if isinstance(other, CromeType):\n            if self.name == other.name and type(self).__name__ == type(other).__name__:\n                return True\n            return False\n        else:\n            raise AttributeError\n\n    def __hash__(self):\n        return hash(self.name + type(self).__name__)\n\n    def is_similar_to(self, other: CromeType) -> bool:\n        return self.name == other.name or other.name in self.refinement_of\n\n\nAnyCromeType = TypeVar(\"AnyCromeType\", bound=CromeType)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crome_logic/typelement/__init__.py b/crome_logic/typelement/__init__.py
--- a/crome_logic/typelement/__init__.py	(revision bb18496a6cc3a638dab82652523c81472eccf5fb)
+++ b/crome_logic/typelement/__init__.py	(date 1655340169040)
@@ -25,7 +25,7 @@
     name: str
     description: str = ""
     kind: TypeKind = TypeKind.UNKNOWN
-    refinement_of: set[str] = field(default_factory=set)
+    refinement_of: set[AnyCromeType | str] = field(default_factory=set)
 
     controllable: bool = field(init=False, default=False)
 
@@ -49,7 +49,17 @@
         return hash(self.name + type(self).__name__)
 
     def is_similar_to(self, other: CromeType) -> bool:
-        return self.name == other.name or other.name in self.refinement_of
+        if self.name == other.name:
+            return True
+        for elem in self.refinement_of:
+            if isinstance(elem, str):
+                if other.name in elem:
+                    return True
+            else:
+                if other.name in elem.name:
+                    return True
+
+        return False
 
 
 AnyCromeType = TypeVar("AnyCromeType", bound=CromeType)
Index: crome_logic/tools/string_manipulation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import hashlib\nimport random\nimport re\nimport string\n\nfrom crome_logic.specification.trees import boolean_tree_to_formula, gen_atoms_tree\n\nmatch_LTL_no_spaces = r\"((?<=[G|F|X])(?=[^\\s]))|((?<=[U])(?=[a-z]))|(?=[U])+(?<=[a-z])\"\n\n\ndef latexit(formula: str) -> str:\n    import spot\n\n    return spot.formula(str(formula))._repr_latex_()\n\n\ndef add_spaces_spot_ltl(formula: str) -> str:\n    \"\"\"TODO: FIX 'TRUE'\"\"\"\n    return re.sub(match_LTL_no_spaces, \" \", formula)\n\n\ndef get_name_and_id(value: str | None = None) -> tuple[str, str]:\n    if value is None:\n        \"\"\"5 character ID generated from a random string.\"\"\"\n        value = \"\".join(random.choices(string.ascii_uppercase + string.digits, k=10))\n    \"\"\"5 character ID generated from the name\"\"\"\n    id = hashlib.sha1(value.encode(\"UTF-8\")).hexdigest()[:5]\n    return value, id\n\n\ndef strix_syntax_fix(text: str) -> str:\n    \"\"\"Adds a space next to the '!' and converts TRUE to true.\"\"\"\n    try:\n        res = re.sub(r\"!(?!\\s)\", \"! \", text)\n        res = res.replace(\"TRUE\", \"true\")\n    except Exception as e:\n        raise e\n    return res\n\n\ndef pyeda_syntax_fix(text: str) -> str:\n    if \"->\" in text:\n        atom_tree = gen_atoms_tree(text)\n        text = boolean_tree_to_formula(atom_tree)\n    return text.replace(\"TRUE\", \"1\").replace(\"FALSE\", \"0\").replace(\"!\", \"~\").replace(\"\\\"\", \"\")\n\n\ndef spot_syntax_fix(text: str) -> str:\n    return text.replace(\"~\", \"!\").replace(\"\\\"\", \"\")\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crome_logic/tools/string_manipulation.py b/crome_logic/tools/string_manipulation.py
--- a/crome_logic/tools/string_manipulation.py	(revision bb18496a6cc3a638dab82652523c81472eccf5fb)
+++ b/crome_logic/tools/string_manipulation.py	(date 1655325024360)
@@ -10,8 +10,10 @@
 
 def latexit(formula: str) -> str:
     import spot
-
-    return spot.formula(str(formula))._repr_latex_()
+    print(f"\nFormula:\t{formula}")
+    f_spot = spot.formula(str(formula))
+    print(f"LaTeX of:\t{str(f_spot)}")
+    return f_spot._repr_latex_()
 
 
 def add_spaces_spot_ltl(formula: str) -> str:
Index: crome_logic/typeset/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\n\nfrom copy import copy, deepcopy\nfrom typing import Iterable\n\nfrom crome_logic.tools.atomic_propositions import extract_ap\nfrom crome_logic.typelement import AnyCromeType, TypeKind, CromeType\nfrom crome_logic.typelement.basic import (\n    Boolean,\n    BooleanControllable,\n    BooleanUncontrollable,\n    BoundedInteger,\n)\n\nBASE_CLASS_TYPES = [\n    \"Boolean\",\n    \"BoundedInteger\",\n    \"BooleanAction\",\n    \"IntegerAction\",\n    \"Active\",\n    \"ContextTime\",\n    \"ContextBooleanTime\",\n    \"ContextLocation\",\n    \"ContextIdentity\",\n    \"ReachLocation\",\n    \"IntegerSensor\",\n    \"BooleanSensor\",\n]\n\n\nclass Typeset(dict[str, AnyCromeType]):\n    \"\"\"set of identifier -> Boolean.\"\"\"\n\n    def __init__(self, types: set[AnyCromeType] | None = None):\n        \"\"\"Indicates the supertypes relationships for each typelement in the\n        typeset.\"\"\"\n        self._super_types: dict[AnyCromeType, set[AnyCromeType]] = {}\n        \"\"\"Indicates the mutex relationships for the typelement in the typeset\"\"\"\n        self._mutex_types: set[frozenset[Boolean]] = set()\n        \"\"\"Indicates the adjacency relationships for the typelement in the typeset\"\"\"\n        self._adjacent_types: dict[Boolean, set[Boolean]] = {}\n\n        if types is not None and len(types) > 0:\n            self._add_elements(types)\n        else:\n            super().__init__()\n\n    @classmethod\n    def from_aps(\n            cls,\n            controllable: set[str] | None = None,\n            uncontrollable: set[str] | None = None,\n    ) -> Typeset:\n\n        crome_types: set[Boolean] = set()\n        if controllable is not None:\n            for ap in controllable:\n                crome_types.add(BooleanControllable(name=ap))\n\n        if uncontrollable is not None:\n            for ap in uncontrollable:\n                crome_types.add(BooleanUncontrollable(name=ap))\n\n        return cls(crome_types)  # type: ignore\n\n    @classmethod\n    def from_typesets(\n            cls,\n            typesets: Iterable[Typeset]\n    ) -> Typeset:\n\n        typeset = cls()\n\n        for t in typesets:\n            typeset += t\n\n        return typeset\n\n    def __setitem__(self, name, elem):\n        self._add_elements({elem})\n\n    def __deepcopy__(self: Typeset, memo):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n        for k, v in self.__dict__.items():\n            setattr(result, k, deepcopy(v))\n        \"\"\"Do not perform a deepcopy of the variables\"\"\"\n        for k, v in self.items():\n            result[k] = v\n        return result\n\n    def __str__(self):\n        ret = \"\"\n        for (key, elem) in self.items():\n            ret += f\"{key}:\\t{elem.name}\"\n            if elem in self.super_types:\n                ret += \" -> \"\n                for supertypes in self.super_types[elem]:\n                    ret += supertypes.name\n            ret += \"\\n\"\n        return ret[:-1]\n\n    def __add__(self, element: Typeset | Boolean) -> Typeset:\n        \"\"\"Returns self + element.\n\n        WARNING: violates Liskov Substitution Principle\n        \"\"\"\n        if isinstance(element, Boolean):\n            element = Typeset({element})\n        \"\"\"Shallow copy\"\"\"\n        new_dict = copy(self)\n        new_dict.__iadd__(element)\n        return new_dict\n\n    def __sub__(self, element: Typeset | Boolean) -> Typeset:\n        \"\"\"Returns self - element\"\"\"\n        if isinstance(element, Boolean):\n            element = Typeset({element})\n        \"\"\"Shallow copy\"\"\"\n        new_dict = copy(self)\n        for key in element.keys():\n            if key in new_dict:\n                del new_dict[key]\n        return new_dict\n\n    def __iadd__(self, element: Typeset | Boolean):\n        \"\"\"Updates self with self += element.\"\"\"\n        if isinstance(element, Boolean):\n            element = Typeset({element})\n        for key, value in element.items():\n            if key in self:\n                if type(value).__name__ != type(self[key]).__name__:\n                    print(\n                        f\"Trying to add an element with key '{key}' and value of typelement '{type(value).__name__}'\"\n                    )\n                    print(\n                        f\"ERROR:\\n\"\n                        f\"There is already en element with key '{key}' and value of typelement '{type(self[key]).__name__}'\"\n                    )\n                    raise Exception(\"Type Mismatch\")\n            if key not in self:\n                self._add_elements({value})\n        return self\n\n    @property\n    def size(self) -> int:\n        return len(list(self.keys()))\n\n    def to_str_nuxmv(self) -> list[str]:\n        tuple_vars = []\n        for k, v in self.items():\n            if isinstance(v, Boolean):\n                tuple_vars.append(f\"{k}: boolean\")\n            elif isinstance(v, BoundedInteger):\n                tuple_vars.append(f\"{k}: {v.min}..{v.max}\")\n        return tuple_vars\n\n    def get_sub_typeset(self, formula: str):\n        set_ap_str = extract_ap(formula)\n        set_of_types = set(filter((lambda x: x.name in set_ap_str), self.values()))\n        return Typeset(set_of_types)\n\n    def _add_elements(self, types: set[AnyCromeType]):\n        if types is not None:\n            for elem in types:\n                super().__setitem__(elem.name, elem)\n\n        self._update_refinements()\n        self._update_mutex()\n        self._update_adjacency()\n\n    def _update_refinements(self) -> None:\n        \"\"\"Updates the refinement relationships in the typeset.\"\"\"\n        if len(self.values()) > 1:\n            for element in self.values():\n                for super_type in element.refinement_of:\n                    if super_type in self.keys():\n                        if element in self._super_types.keys():\n                            self._super_types[element].add(self[super_type])\n                        else:\n                            self._super_types[element] = {self[super_type]}\n\n    def _update_mutex(self) -> None:\n        \"\"\"Updates the mutually exclusion relationships in the typeset.\"\"\"\n        if len(self.values()) > 1:\n            self._mutex_types = set()\n            mutex_vars_dict: dict[str, set[Boolean]] = {}\n            for variable in self.values():\n                if isinstance(variable, Boolean):\n                    if variable.mutex_group != \"\":\n                        if variable.mutex_group in mutex_vars_dict:\n                            mutex_vars_dict[variable.mutex_group].add(variable)\n                        else:\n                            mutex_vars_dict[variable.mutex_group] = set()\n                            mutex_vars_dict[variable.mutex_group].add(variable)\n            for vars in mutex_vars_dict.values():\n                self._mutex_types.add(frozenset(vars))\n\n    def _update_adjacency(self) -> None:\n        \"\"\"Updates the adjacency relationships in the typeset.\"\"\"\n        if len(self.values()) > 1:\n            self._adjacent_types = {}\n            for variable in self.values():\n                if isinstance(variable, Boolean):\n                    if len(list(variable.adjacency_set)) != 0:\n                        self._adjacent_types[variable] = {variable}\n                        adjacent_types = filter(lambda x: x.name in variable.adjacency_set, self.values())\n                        self._adjacent_types[variable] |= set(adjacent_types)\n\n    @property\n    def super_types(self) -> dict[AnyCromeType, set[AnyCromeType]]:\n        return self._super_types\n\n    @property\n    def mutex_types(self) -> set[frozenset[Boolean]]:\n        return self._mutex_types\n\n    @property\n    def adjacent_types(self) -> dict[Boolean, set[Boolean]]:\n        return self._adjacent_types\n\n    def n_elements_in_common_with(self, other: Typeset) -> int:\n        return len(set(self.keys()).intersection(other.keys()))\n\n    def similar_types(self, other: Typeset) -> set[CromeType]:\n        \"\"\"Returns the types that are 'similar' to the types in typeset\n        \"\"\"\n        similar_to: set[CromeType] = set()\n        similar_types: set[CromeType] = set()\n        for st in self.values():\n            for ot in other.values():\n                if st.is_similar_to(ot) and ot not in similar_to:\n                    similar_types.add(st)\n                    similar_to.add(ot)\n        return similar_types\n\n    def similarity_score(self, other: Typeset) -> float:\n        \"\"\"Returns the percentage of types similar to 'other'\n        \"\"\"\n        return len(self.similar_types(other)) / other.size * 100\n\n    @property\n    def split_controllable_uncontrollable(self) -> tuple[Typeset, Typeset]:\n        t_c = Typeset()\n        t_u = Typeset()\n        for t in self.values():\n            if t.controllable:\n                t_c += t\n            else:\n                t_u += t\n        return t_c, t_u\n\n    def extract_inputs_outputs(\n            self, string: bool = False\n    ) -> tuple[set[Boolean], set[Boolean]] | tuple[set[str], list[str]]:\n        \"\"\"Returns a set of variables in the typeset that are not controllable\n        and controllable.\"\"\"\n        i: set[Boolean] = set()\n        i_str: set[str] = set()\n        o: set[Boolean] = set()\n        o_str: set[str] = set()\n        if len(self.values()) > 0:\n            for t in self.values():\n                if isinstance(t, Boolean):\n                    if not t.controllable:\n                        if string:\n                            i_str.add(t.name)\n                        else:\n                            i.add(t)\n                    else:\n                        if string:\n                            o_str.add(t.name)\n                        else:\n                            o.add(t)\n        if string:\n            return i_str, o_str\n        return list(i), list(o)\n\n    def extract_viewpoint(self):\n        for v in self.values():\n            if v.kind == TypeKind.LOCATION:\n                return \"location\"\n            elif v.kind == TypeKind.ACTION:\n                return \"action\"\n        return \"other\"\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crome_logic/typeset/__init__.py b/crome_logic/typeset/__init__.py
--- a/crome_logic/typeset/__init__.py	(revision bb18496a6cc3a638dab82652523c81472eccf5fb)
+++ b/crome_logic/typeset/__init__.py	(date 1655340291349)
@@ -34,7 +34,7 @@
     def __init__(self, types: set[AnyCromeType] | None = None):
         """Indicates the supertypes relationships for each typelement in the
         typeset."""
-        self._super_types: dict[AnyCromeType, set[AnyCromeType]] = {}
+        self._super_types: dict[AnyCromeType, set[AnyCromeType | str]] = {}
         """Indicates the mutex relationships for the typelement in the typeset"""
         self._mutex_types: set[frozenset[Boolean]] = set()
         """Indicates the adjacency relationships for the typelement in the typeset"""
@@ -103,13 +103,13 @@
 
     def __add__(self, element: Typeset | Boolean) -> Typeset:
         """Returns self + element.
-
+        If refinements are found, it concretize all the abstract variables
         WARNING: violates Liskov Substitution Principle
         """
         if isinstance(element, Boolean):
             element = Typeset({element})
-        """Shallow copy"""
-        new_dict = copy(self)
+
+        new_dict = Typeset(set(self.values()))
         new_dict.__iadd__(element)
         return new_dict
 
@@ -175,11 +175,13 @@
         if len(self.values()) > 1:
             for element in self.values():
                 for super_type in element.refinement_of:
-                    if super_type in self.keys():
-                        if element in self._super_types.keys():
-                            self._super_types[element].add(self[super_type])
-                        else:
-                            self._super_types[element] = {self[super_type]}
+                    if isinstance(super_type, str):
+                        if super_type in self.keys():
+                            super_type = self[super_type]
+                    if element in self._super_types.keys():
+                        self._super_types[element].add(super_type)
+                    else:
+                        self._super_types[element] = {super_type}
 
     def _update_mutex(self) -> None:
         """Updates the mutually exclusion relationships in the typeset."""
@@ -210,6 +212,14 @@
 
     @property
     def super_types(self) -> dict[AnyCromeType, set[AnyCromeType]]:
+
+        for t, set_super_types in self._super_types.items():
+            super_types_str = set(filter(lambda t: isinstance(t, str), set_super_types))
+            set_super_types -= super_types_str
+            for type_str in super_types_str:
+                set_super_types |= self[type_str]
+            self._super_types[t] = set_super_types
+
         return self._super_types
 
     @property

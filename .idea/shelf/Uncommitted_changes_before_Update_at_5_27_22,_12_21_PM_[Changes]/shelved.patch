Index: crome_logic/specification/temporal/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\n\nfrom copy import deepcopy\nfrom dataclasses import dataclass, fields\n\nimport spot\nfrom treelib import Tree\n\nfrom crome_logic.patterns import Pattern\nfrom crome_logic.specification import Cnf, Dnf, Specification\nfrom crome_logic.specification.boolean import Bool\nfrom crome_logic.specification.temporal.tools import transform_spot_tree\nfrom crome_logic.specification.tools import is_true_string\nfrom crome_logic.specification.trees import (\n    boolean_tree_to_formula,\n    extract_atoms_dictionary,\n    gen_atoms_tree,\n    gen_ltl_tree,\n)\nfrom crome_logic.tools.atomic_propositions import extract_ap\nfrom crome_logic.tools.nuxmv import check_satisfiability, check_validity\nfrom crome_logic.typelement.basic import Boolean\nfrom crome_logic.typeset import Typeset\n\n\n@dataclass(frozen=True)\nclass LTL(Specification):\n    _init_formula: str | Pattern\n    _typeset: Typeset | None = None\n    _boolean: Bool | None = None\n    _kind: Specification.Kind = Specification.Kind.UNDEFINED\n    _expression: spot.formula | None = None\n    _tree: Tree | None = None\n\n    @property\n    def boolean(self) -> Bool:\n        if isinstance(self._boolean, Bool):\n            return self._boolean\n        raise AttributeError\n\n    @property\n    def kind(self) -> Specification.Kind:\n        return self._kind\n\n    @property\n    def expression(self) -> spot.formula:\n        return self._expression\n\n    @property\n    def tree(self) -> Tree:\n        return self._tree\n\n    def __post_init__(self):\n        if isinstance(self._init_formula, Pattern):\n            object.__setattr__(self, \"_init_formula\", str(self._init_formula))\n        self._initialize_external_libraries_objects(self._init_formula)\n\n        if self._typeset is None:\n            set_ap_str = extract_ap(self.expression)\n            set_ap = set(map(lambda x: Boolean(name=x), set_ap_str))\n            typeset = Typeset(set_ap)\n        else:\n            typeset = self.typeset.get_sub_typeset(str(self.expression))\n        object.__setattr__(self, \"_typeset\", typeset)\n\n    def _initialize_external_libraries_objects(self, formula: str):\n        expression = transform_spot_tree(spot.formula(formula))\n        object.__setattr__(self, \"_expression\", expression)\n        if self._boolean is None:\n            atom_tree = gen_atoms_tree(spot_f=self.expression)\n            boolean = Bool(\n                _init_formula=boolean_tree_to_formula(atom_tree), _tree=atom_tree\n            )\n            object.__setattr__(self, \"_boolean\", boolean)\n        tree: Tree = gen_ltl_tree(spot_f=self.expression)\n        object.__setattr__(self, \"_tree\", tree)\n\n    @classmethod\n    def from_pattern(cls, formula: Pattern, typeset: Typeset | None = None) -> LTL:\n        return cls(_init_formula=str(formula), _typeset=typeset)\n\n    def __hash__(self: LTL):\n        return hash(str(self))\n\n    @property\n    def formula(self) -> str:\n        return str(self.expression)\n\n\n    @property\n    def typeset_complete(self) -> Typeset:\n        return self.typeset + self.refinement_rules.typeset + self.adjacency_and_mutex_rules.typeset\n\n    def __str__(self):\n        return self.formula\n\n    def __deepcopy__(self: LTL, memo):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        for field in fields(cls):\n            if not (\n                    field.name == \"_boolean\"\n                    or field.name == \"_expression\"\n                    or field.name == \"_tree\"\n            ):\n                object.__setattr__(\n                    result, field.name, deepcopy(getattr(self, field.name))\n                )\n        result._initialize_external_libraries_objects(result.init_formula)\n        return result\n\n    @property\n    def print_summary(self) -> str:\n        ret = (\n            f\"\\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\"\n            f\"LTL SIMPLIFIED\\n\"\n            f\"{str(self)}\\n\\n\"\n            f\"BOOLEAN REPRESENTATION\\n\"\n            f\"{str(self.boolean)}\\n\\n\"\n            f\"LTL CNF (from booleans)\\n\"\n            f\"{self.cnf.to_str}\\n\\n\"\n            f\"LTL DNF (from booleans)\\n\"\n            f\"{self.dnf.to_str}\\n\"\n            f\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\n\"\n        )\n        return ret\n\n    @property\n    def cnf(self) -> Cnf:\n        atoms_cnf = self.boolean.cnf.clauses\n        cnf_list = []\n        atoms_dictionary = extract_atoms_dictionary(self.boolean.tree)\n        for clauses in atoms_cnf:\n            atoms = set()\n            for atom in clauses:\n                atom_str: str = str(atom)\n                if atom_str.startswith(\"!\"):\n                    ltl_formula = f\"!{atoms_dictionary[atom_str[1:]]}\"\n                else:\n                    ltl_formula = atoms_dictionary[str(atom)]\n                ltl_object = LTL(\n                    _init_formula=ltl_formula,\n                    _typeset=self.typeset.get_sub_typeset(ltl_formula),\n                )\n                atoms.add(ltl_object)\n            cnf_list.append(atoms)\n        return Cnf(cnf_list)  # type: ignore\n\n    @property\n    def dnf(self) -> Dnf:\n        atoms_dnf = self.boolean.dnf.clauses\n        dnf_list = []\n        atoms_dictionary = extract_atoms_dictionary(self.boolean.tree)\n        for clauses in atoms_dnf:\n            atoms = set()\n            for atom in clauses:\n                atom_str: str = str(atom)\n                if atom_str.startswith(\"!\"):\n                    ltl_formula = f\"!{atoms_dictionary[atom_str[1:]]}\"\n                else:\n                    ltl_formula = atoms_dictionary[str(atom)]\n                ltl_object = LTL(\n                    _init_formula=ltl_formula,\n                    _typeset=self.typeset.get_sub_typeset(ltl_formula),\n                )\n                atoms.add(ltl_object)\n            dnf_list.append(atoms)\n        return Dnf(dnf_list)  # type: ignore\n\n    def __iand__(self: Specification, other: Specification) -> LTL:\n        \"\"\"self &= other Modifies self with the conjunction with other.\"\"\"\n        if not (isinstance(self, LTL) and isinstance(other, LTL)):\n            raise AttributeError\n        if self.is_true_expression:\n            init_formula = deepcopy(other.formula)\n            typeset = deepcopy(other.typeset)\n            boolean = deepcopy(other.boolean)\n            object.__setattr__(self, \"_init_formula\", init_formula)\n            object.__setattr__(self, \"_typeset\", typeset)\n            object.__setattr__(self, \"_boolean\", boolean)\n\n            self.__post_init__()  # type: ignore\n\n            return self\n\n        if other.is_true_expression:\n            return self\n\n        init_formula = f\"({str(self)}) & ({str(other)})\"\n        typeset = self.typeset + other.typeset\n        boolean = self.boolean & other.boolean\n\n        object.__setattr__(self, \"_init_formula\", init_formula)\n        object.__setattr__(self, \"_typeset\", typeset)\n        object.__setattr__(self, \"_boolean\", boolean)\n\n        self.__post_init__()  # type: ignore\n\n        return self\n\n    def __ior__(self: Specification, other: Specification) -> LTL:\n        \"\"\"self |= other Modifies self with the disjunction with other.\"\"\"\n        if not (isinstance(self, LTL) and isinstance(other, LTL)):\n            raise AttributeError\n        if self.is_true_expression or other.is_true_expression:\n            init_formula = f\"TRUE\"\n        else:\n            init_formula = f\"({str(self)}) | ({str(other)})\"\n\n        typeset = self.typeset + other.typeset\n        boolean = self.boolean | other.boolean\n        object.__setattr__(self, \"_init_formula\", init_formula)\n        object.__setattr__(self, \"_typeset\", typeset)\n        object.__setattr__(self, \"_boolean\", boolean)\n\n        self.__post_init__()  # type: ignore\n\n        return self\n\n    def __and__(self: Specification, other: Specification) -> LTL:\n        \"\"\"self & other Returns a new LTL with the conjunction with other.\"\"\"\n        if not (isinstance(self, LTL) and isinstance(other, LTL)):\n            raise AttributeError\n        if self.is_true_expression:\n            return LTL(\n                _init_formula=str(other),\n                _boolean=other.boolean,\n                _typeset=other.typeset,\n            )\n\n        if other.is_true_expression:\n            return LTL(\n                _init_formula=str(self),\n                _boolean=self.boolean,\n                _typeset=self.typeset,\n            )\n\n        return LTL(\n            _init_formula=f\"({str(self)}) & ({str(other)})\",\n            _boolean=self.boolean & other.boolean,\n            _typeset=self.typeset + other.typeset,\n        )\n\n    def __or__(self: Specification, other: Specification) -> LTL:\n        \"\"\"self | other Returns a new LTL with the disjunction with other.\"\"\"\n        if not (isinstance(self, LTL) and isinstance(other, LTL)):\n            raise AttributeError\n        if self.is_true_expression or other.is_true_expression:\n            return LTL(\"TRUE\")\n\n        return LTL(\n            _init_formula=f\"({str(self)}) | ({str(other)})\",\n            _boolean=self.boolean | other.boolean,\n            _typeset=self.typeset + other.typeset,\n        )\n\n    def __invert__(self: Specification) -> LTL:\n        \"\"\"Returns a new LTL with the negation of self.\"\"\"\n        if not isinstance(self, LTL):\n            raise AttributeError\n        return LTL(\n            _init_formula=f\"!({self.expression})\",\n            _boolean=~self.boolean,\n            _typeset=self.typeset,\n        )\n\n    def __rshift__(self: Specification, other: Specification) -> LTL:\n        \"\"\">> Returns a new LTL that is the result of self -> other\n        (implies)\"\"\"\n        if not (isinstance(self, LTL) and isinstance(other, LTL)):\n            raise AttributeError\n        if self.is_true_expression:\n            return LTL(\n                _init_formula=str(other),\n                _boolean=other.boolean,\n                _typeset=other.typeset,\n            )\n\n        return LTL(\n            _init_formula=f\"({self.expression}) -> ({other.expression})\",\n            _boolean=self.boolean >> other.boolean,\n            _typeset=self.typeset + other.typeset,\n        )\n\n    @property\n    def adjacency_and_mutex_rules(self) -> LTL:\n        from crome_logic.specification.rules_extractors import (\n            extract_adjacency_rules, extract_mutex_rules\n        )\n\n        return extract_mutex_rules(self.typeset) & extract_adjacency_rules(self.typeset)\n\n    @property\n    def refinement_rules(self) -> LTL:\n        from crome_logic.specification.rules_extractors import (\n            extract_refinement_rules\n        )\n\n        return extract_refinement_rules(self.typeset)\n\n    @property\n    def is_satisfiable(self: LTL) -> bool:\n\n        new_f = self & self.adjacency_and_mutex_rules\n\n        return check_satisfiability(str(new_f), new_f.typeset.to_str_nuxmv())\n\n    @property\n    def is_valid(self: LTL) -> bool:\n\n        if isinstance(self.kind, LTL.Kind.Rule):\n            return check_validity(str(self), self.typeset.to_str_nuxmv())\n\n        new_f = self.refinement_rules >> self\n\n        return check_validity(str(new_f), new_f.typeset.to_str_nuxmv())\n\n    @property\n    def is_true_expression(self) -> bool:\n        if is_true_string(str(self)):\n            return True\n\n    def __lt__(self, other: LTL):\n        \"\"\"self < other.\n\n        True if self is a refinement but not equal to other\n        \"\"\"\n        return self.__le__(other) and self.__ne__(other)\n\n    def __le__(self: LTL, other: LTL):\n        \"\"\"self <= other.\n\n        True if self is a refinement of other\n        \"\"\"\n        \"\"\"Check if (self -> other) is valid\"\"\"\n        return (self >> other).is_valid\n\n    def __gt__(self, other: LTL):\n        \"\"\"self > other.\n\n        True if self is an abstraction but not equal to other\n        \"\"\"\n        return self.__ge__(other) and self.__ne__(other)\n\n    def __ge__(self, other: LTL):\n        \"\"\"self >= other.\n\n        True if self is an abstraction of other\n        \"\"\"\n        \"\"\"Check if (other -> self) is valid\"\"\"\n        return (other >> self).is_valid\n\n    def __eq__(self, other: object):\n        \"\"\"Check if self == other.\"\"\"\n        if not isinstance(other, LTL):\n            return NotImplemented\n        if str(self) == str(other):\n            return True\n        else:\n            not_self = ~self\n            if str(not_self) == str(other):\n                return False\n            return self.__le__(other) and self.__ge__(other)\n\n    def __ne__(self, other: object):\n        \"\"\"Check if self != other.\"\"\"\n        if not isinstance(other, LTL):\n            return NotImplemented\n        return not self.__eq__(other)\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        del state[\"_tree\"]\n        state[\"_expression\"] = str(self.expression)\n        state[\"_boolean\"] = str(self.boolean)\n        state[\"_boolean_typeset\"] = self.boolean.typeset\n\n        return state\n\n    def __setstate__(self, state):\n        expression = state[\"_expression\"]\n        boolean = state[\"_boolean\"]\n        boolean_typeset = state[\"_boolean_typeset\"]\n        del state[\"_expression\"]\n        del state[\"_boolean\"]\n        del state[\"_boolean_typeset\"]\n        self.__dict__.update(state)\n        init_formula = expression\n        boolean = Bool(_init_formula=boolean, _typeset=boolean_typeset)\n        object.__setattr__(self, \"_init_formula\", init_formula)\n        object.__setattr__(self, \"_boolean\", boolean)\n        self.__post_init__()  # type: ignore\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crome_logic/specification/temporal/__init__.py b/crome_logic/specification/temporal/__init__.py
--- a/crome_logic/specification/temporal/__init__.py	(revision 276a868393db37302a531f32727b575237535440)
+++ b/crome_logic/specification/temporal/__init__.py	(date 1653679296744)
@@ -20,6 +20,7 @@
 from crome_logic.tools.atomic_propositions import extract_ap
 from crome_logic.tools.nuxmv import check_satisfiability, check_validity
 from crome_logic.typelement.basic import Boolean
+from crome_logic.typelement.robotic import BooleanLocation, BooleanSensor
 from crome_logic.typeset import Typeset
 
 
@@ -86,6 +87,9 @@
     def formula(self) -> str:
         return str(self.expression)
 
+    @property
+    def typeset(self) -> Typeset:
+        return self._typeset
 
     @property
     def typeset_complete(self) -> Typeset:
@@ -167,6 +171,27 @@
             dnf_list.append(atoms)
         return Dnf(dnf_list)  # type: ignore
 
+    def export_to_json(self):
+        json_content = {}
+        if self.formula == "1":
+            json_content = {"ltl_value": "true",
+                            "world_values": [[], [], []]}
+        else:
+            sensor = []
+            location = []
+            action = []
+            typeset = self.typeset
+            for keyType in typeset:
+                if type(typeset[keyType]) == BooleanSensor:
+                    sensor.append(keyType)
+                elif type(typeset[keyType]) == BooleanLocation:
+                    location.append(keyType)
+                else:
+                    action.append(keyType)
+            json_content = {"ltl_value": self.formula,
+                            "world_values": [sensor, action, location]}
+        return json_content
+
     def __iand__(self: Specification, other: Specification) -> LTL:
         """self &= other Modifies self with the conjunction with other."""
         if not (isinstance(self, LTL) and isinstance(other, LTL)):
Index: crome_logic/typeset/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\n\nfrom copy import copy, deepcopy\nfrom typing import Iterable\n\nfrom crome_logic.tools.atomic_propositions import extract_ap\nfrom crome_logic.typelement import AnyCromeType, TypeKind, CromeType\nfrom crome_logic.typelement.basic import (\n    Boolean,\n    BooleanControllable,\n    BooleanUncontrollable,\n    BoundedInteger,\n)\n\nBASE_CLASS_TYPES = [\n    \"Boolean\",\n    \"BoundedInteger\",\n    \"BooleanAction\",\n    \"IntegerAction\",\n    \"Active\",\n    \"ContextTime\",\n    \"ContextBooleanTime\",\n    \"ContextLocation\",\n    \"ContextIdentity\",\n    \"ReachLocation\",\n    \"IntegerSensor\",\n    \"BooleanSensor\",\n]\n\n\nclass Typeset(dict[str, AnyCromeType]):\n    \"\"\"set of identifier -> Boolean.\"\"\"\n\n    def __init__(self, types: set[AnyCromeType] | None = None):\n        \"\"\"Indicates the supertypes relationships for each typelement in the\n        typeset.\"\"\"\n        self._super_types: dict[AnyCromeType, set[AnyCromeType]] = {}\n        \"\"\"Indicates the mutex relationships for the typelement in the typeset\"\"\"\n        self._mutex_types: set[frozenset[Boolean]] = set()\n        \"\"\"Indicates the adjacency relationships for the typelement in the typeset\"\"\"\n        self._adjacent_types: dict[Boolean, set[Boolean]] = {}\n\n        if types is not None and len(types) > 0:\n            self._add_elements(types)\n        else:\n            super().__init__()\n\n    @classmethod\n    def from_aps(\n            cls,\n            controllable: set[str] | None = None,\n            uncontrollable: set[str] | None = None,\n    ) -> Typeset:\n\n        crome_types: set[Boolean] = set()\n        if controllable is not None:\n            for ap in controllable:\n                crome_types.add(BooleanControllable(name=ap))\n\n        if uncontrollable is not None:\n            for ap in uncontrollable:\n                crome_types.add(BooleanUncontrollable(name=ap))\n\n        return cls(crome_types)  # type: ignore\n\n    @classmethod\n    def from_typesets(\n            cls,\n            typesets: Iterable[Typeset]\n    ) -> Typeset:\n\n        typeset = cls()\n\n        for t in typesets:\n            typeset += t\n\n        return typeset\n\n    def __setitem__(self, name, elem):\n        self._add_elements({elem})\n\n    def __deepcopy__(self: Typeset, memo):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n        for k, v in self.__dict__.items():\n            setattr(result, k, deepcopy(v))\n        \"\"\"Do not perform a deepcopy of the variables\"\"\"\n        for k, v in self.items():\n            result[k] = v\n        return result\n\n    def __str__(self):\n        ret = \"\"\n        for (key, elem) in self.items():\n            ret += f\"{key}:\\t{elem.name}\"\n            if elem in self.super_types:\n                ret += \" -> \"\n                for supertypes in self.super_types[elem]:\n                    ret += supertypes.name\n            ret += \"\\n\"\n        return ret[:-1]\n\n    def __add__(self, element: Typeset | Boolean) -> Typeset:\n        \"\"\"Returns self + element.\n\n        WARNING: violates Liskov Substitution Principle\n        \"\"\"\n        if isinstance(element, Boolean):\n            element = Typeset({element})\n        \"\"\"Shallow copy\"\"\"\n        new_dict = copy(self)\n        new_dict.__iadd__(element)\n        return new_dict\n\n    def __sub__(self, element: Typeset | Boolean) -> Typeset:\n        \"\"\"Returns self - element\"\"\"\n        if isinstance(element, Boolean):\n            element = Typeset({element})\n        \"\"\"Shallow copy\"\"\"\n        new_dict = copy(self)\n        for key in element.keys():\n            if key in new_dict:\n                del new_dict[key]\n        return new_dict\n\n    def __iadd__(self, element: Typeset | Boolean):\n        \"\"\"Updates self with self += element.\"\"\"\n        if isinstance(element, Boolean):\n            element = Typeset({element})\n        for key, value in element.items():\n            if key in self:\n                if type(value).__name__ != type(self[key]).__name__:\n                    print(\n                        f\"Trying to add an element with key '{key}' and value of typelement '{type(value).__name__}'\"\n                    )\n                    print(\n                        f\"ERROR:\\n\"\n                        f\"There is already en element with key '{key}' and value of typelement '{type(self[key]).__name__}'\"\n                    )\n                    raise Exception(\"Type Mismatch\")\n            if key not in self:\n                self._add_elements({value})\n        return self\n\n    @property\n    def size(self) -> int:\n        return len(list(self.keys()))\n\n    def to_str_nuxmv(self) -> list[str]:\n        tuple_vars = []\n        for k, v in self.items():\n            if isinstance(v, Boolean):\n                tuple_vars.append(f\"{k}: boolean\")\n            elif isinstance(v, BoundedInteger):\n                tuple_vars.append(f\"{k}: {v.min}..{v.max}\")\n        return tuple_vars\n\n    def get_sub_typeset(self, formula: str):\n        set_ap_str = extract_ap(formula)\n        set_of_types = set(filter((lambda x: x.name in set_ap_str), self.values()))\n        return Typeset(set_of_types)\n\n    def _add_elements(self, types: set[AnyCromeType]):\n        if types is not None:\n            for elem in types:\n                super().__setitem__(elem.name, elem)\n\n        self._update_refinements()\n        self._update_mutex()\n        self._update_adjacency()\n\n    def _update_refinements(self) -> None:\n        \"\"\"Updates the refinement relationships in the typeset.\"\"\"\n        if len(self.values()) > 1:\n            for element in self.values():\n                for super_type in element.refinement_of:\n                    if super_type in self.keys():\n                        if element in self._super_types.keys():\n                            self._super_types[element].add(self[super_type])\n                        else:\n                            self._super_types[element] = {self[super_type]}\n\n    def _update_mutex(self) -> None:\n        \"\"\"Updates the mutually exclusion relationships in the typeset.\"\"\"\n        if len(self.values()) > 1:\n            self._mutex_types = set()\n            mutex_vars_dict: dict[str, set[Boolean]] = {}\n            for variable in self.values():\n                if isinstance(variable, Boolean):\n                    if variable.mutex_group != \"\":\n                        if variable.mutex_group in mutex_vars_dict:\n                            mutex_vars_dict[variable.mutex_group].add(variable)\n                        else:\n                            mutex_vars_dict[variable.mutex_group] = set()\n                            mutex_vars_dict[variable.mutex_group].add(variable)\n            for vars in mutex_vars_dict.values():\n                self._mutex_types.add(frozenset(vars))\n\n    def _update_adjacency(self) -> None:\n        \"\"\"Updates the adjacency relationships in the typeset.\"\"\"\n        if len(self.values()) > 1:\n            self._adjacent_types = {}\n            for variable in self.values():\n                if isinstance(variable, Boolean):\n                    if len(list(variable.adjacency_set)) != 0:\n                        self._adjacent_types[variable] = {variable}\n                        adjacent_types = filter(lambda x: x.name in variable.adjacency_set, self.values())\n                        self._adjacent_types[variable] |= set(adjacent_types)\n\n    @property\n    def super_types(self) -> dict[AnyCromeType, set[AnyCromeType]]:\n        return self._super_types\n\n    @property\n    def mutex_types(self) -> set[frozenset[Boolean]]:\n        return self._mutex_types\n\n    @property\n    def adjacent_types(self) -> dict[Boolean, set[Boolean]]:\n        return self._adjacent_types\n\n    def similar_types(self, other: Typeset) -> set[CromeType]:\n        \"\"\"Returns the types that are 'similar' to the types in typeset\n        \"\"\"\n        similar_types: set[CromeType] = set()\n        for st in self.values():\n            for ot in other.values():\n                if st.is_similar_to(ot):\n                    similar_types.add(st)\n        return similar_types\n\n    def similarity_score(self, other: Typeset) -> float:\n        \"\"\"Returns the percentage of types similar to 'other'\n        \"\"\"\n        return len(self.similar_types(other)) / other.size * 100\n\n    def extract_inputs_outputs(\n            self, string: bool = False\n    ) -> tuple[set[Boolean], set[Boolean]] | tuple[set[str], list[str]]:\n        \"\"\"Returns a set of variables in the typeset that are not controllable\n        and controllable.\"\"\"\n        i: set[Boolean] = set()\n        i_str: set[str] = set()\n        o: set[Boolean] = set()\n        o_str: set[str] = set()\n        if len(self.values()) > 0:\n            for t in self.values():\n                if isinstance(t, Boolean):\n                    if not t.controllable:\n                        if string:\n                            i_str.add(t.name)\n                        else:\n                            i.add(t)\n                    else:\n                        if string:\n                            o_str.add(t.name)\n                        else:\n                            o.add(t)\n        if string:\n            return i_str, o_str\n        return list(i), list(o)\n\n    def extract_viewpoint(self):\n        for v in self.values():\n            if v.kind == TypeKind.LOCATION:\n                return \"location\"\n            elif v.kind == TypeKind.ACTION:\n                return \"action\"\n        return \"other\"\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crome_logic/typeset/__init__.py b/crome_logic/typeset/__init__.py
--- a/crome_logic/typeset/__init__.py	(revision 276a868393db37302a531f32727b575237535440)
+++ b/crome_logic/typeset/__init__.py	(date 1653679296743)
@@ -69,11 +69,9 @@
             typesets: Iterable[Typeset]
     ) -> Typeset:
 
-        typeset = cls()
-
+        typeset = Typeset()
         for t in typesets:
             typeset += t
-
         return typeset
 
     def __setitem__(self, name, elem):

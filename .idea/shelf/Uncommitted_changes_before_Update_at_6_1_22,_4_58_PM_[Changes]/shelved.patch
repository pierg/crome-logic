Index: crome_logic/specification/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\n\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\n\nfrom aenum import Enum, auto, skip\n\nfrom crome_logic.specification.string_logic import and_, or_\nfrom crome_logic.typeset import Typeset\n\n\nclass Specification(ABC):\n    \"\"\"Base class representing a specification\n\n    Attributes:\n        formula (str): A string representation of the specification in a syntax compatible with spot\n        typeset (Typeset)\n    \"\"\"\n\n    _init_formula: str\n    _typeset: Typeset | None = None\n\n    @property\n    def init_formula(self) -> str:\n        if isinstance(self._init_formula, str):\n            return self._init_formula\n        else:\n            raise AttributeError\n\n    @property\n    def typeset(self) -> Typeset:\n        if isinstance(self._typeset, Typeset):\n            return self._typeset\n        else:\n            raise AttributeError\n\n\n    @property\n    def formula(self) -> str:\n        pass\n\n    class Kind(Enum):\n        UNDEFINED = auto()\n\n        @skip\n        class Atom(Enum):\n            ACTION = auto()\n            SENSOR = auto()\n            LOCATION = auto()\n            CONTEXT = auto()\n            ACTIVE = auto()\n\n        @skip\n        class Rule(Enum):\n            REFINEMENT = auto()\n            MUTEX = auto()\n            ADJACENCY = auto()\n            LIVENESS = auto()\n\n    class OutputStr(Enum):\n        DEFAULT = auto()\n        CNF = auto()\n        DNF = auto()\n        SUMMARY = auto()\n\n    @property\n    @abstractmethod\n    def cnf(self) -> Cnf:\n        pass\n\n    @property\n    @abstractmethod\n    def dnf(self) -> Dnf:\n        pass\n\n    @property\n    @abstractmethod\n    def is_satisfiable(self: Specification) -> bool:\n        pass\n\n    @property\n    @abstractmethod\n    def is_valid(self: Specification) -> bool:\n        pass\n\n    @abstractmethod\n    def __and__(self: Specification, other: Specification) -> Specification:\n        pass\n\n    @abstractmethod\n    def __or__(self: Specification, other: Specification) -> Specification:\n        pass\n\n    @abstractmethod\n    def __invert__(self: Specification) -> Specification:\n        pass\n\n    @abstractmethod\n    def __rshift__(self: Specification, other: Specification) -> Specification:\n        pass\n\n    @abstractmethod\n    def __iand__(self: Specification, other: Specification) -> Specification:\n        pass\n\n    @abstractmethod\n    def __ior__(self: Specification, other: Specification) -> Specification:\n        pass\n\n\n@dataclass\nclass Cnf:\n    clauses: list[set[Specification]]\n\n    @property\n    def to_str(self) -> str:\n        return \" & \".join([or_([str(e) for e in elem]) for elem in self.clauses])\n\n    @property\n    def to_set(self) -> set[Specification]:\n        and_clauses: set[Specification] = set()\n        for or_clause in self.clauses:\n            or_clause_list = list(or_clause)\n            clause = or_clause_list[0]\n            for elem in or_clause_list[1:]:\n                clause |= elem\n            and_clauses.add(clause)\n        return and_clauses\n\n    def __str__(self):\n        return self.to_str\n\n\n@dataclass\nclass Dnf:\n    clauses: list[set[Specification]]\n\n    @property\n    def to_str(self) -> str:\n        return \" | \".join(\n            [and_([str(e) for e in elem], brackets=True) for elem in self.clauses]\n        )\n\n    @property\n    def to_set(self) -> set[Specification]:\n        or_clauses: set[Specification] = set()\n        for and_clause in self.clauses:\n            and_clause_list = list(and_clause)\n            clause = and_clause_list[0]\n            for elem in and_clause_list[1:]:\n                clause &= elem\n            or_clauses.add(clause)\n        return or_clauses\n\n    def __str__(self):\n        return self.to_str\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crome_logic/specification/__init__.py b/crome_logic/specification/__init__.py
--- a/crome_logic/specification/__init__.py	(revision ccbaf32c1b4bd5f61f4943b973848d7597f82211)
+++ b/crome_logic/specification/__init__.py	(date 1654110049416)
@@ -114,7 +114,11 @@
 
     @property
     def to_str(self) -> str:
-        return " & ".join([or_([str(e) for e in elem]) for elem in self.clauses])
+        return " & ".join(self.to_str_list)
+
+    @property
+    def to_str_list(self) -> list[str]:
+        return [or_([str(e) for e in elem]) for elem in self.clauses]
 
     @property
     def to_set(self) -> set[Specification]:
@@ -137,9 +141,12 @@
 
     @property
     def to_str(self) -> str:
-        return " | ".join(
-            [and_([str(e) for e in elem], brackets=True) for elem in self.clauses]
-        )
+        return " | ".join(self.to_str_list)
+
+    @property
+    def to_str_list(self) -> list[str]:
+        return [and_([str(e) for e in elem], brackets=True) for elem in self.clauses]
+
 
     @property
     def to_set(self) -> set[Specification]:
Index: output/nusmvfile.smv
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>MODULE main\nVAR\n\tl5: boolean;\n\tl1: boolean;\n\tg: boolean;\n\tlf: boolean;\n\tlb: boolean;\n\ts: boolean;\n\tl3: boolean;\n\nLTLSPEC (G (!l1 | lf) & G (!l3 | lf) & G (!l5 | lb)) -> ((G F l1 & G F l5 & G F l3) -> (G F (lf & F lb) & (!lb U lf) & G (lb -> X (!lb U lf)) & G (lf -> X (!lf U lb)) & G (s -> g)))\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/output/nusmvfile.smv b/output/nusmvfile.smv
--- a/output/nusmvfile.smv	(revision ccbaf32c1b4bd5f61f4943b973848d7597f82211)
+++ b/output/nusmvfile.smv	(date 1654033027417)
@@ -1,11 +1,11 @@
 MODULE main
 VAR
-	l5: boolean;
-	l1: boolean;
-	g: boolean;
-	lf: boolean;
-	lb: boolean;
-	s: boolean;
-	l3: boolean;
+	register: boolean;
+	r2: boolean;
+	r4: boolean;
+	r3: boolean;
+	greet: boolean;
+	person: boolean;
+	r1: boolean;
 
-LTLSPEC (G (!l1 | lf) & G (!l3 | lf) & G (!l5 | lb)) -> ((G F l1 & G F l5 & G F l3) -> (G F (lf & F lb) & (!lb U lf) & G (lb -> X (!lb U lf)) & G (lf -> X (!lf U lb)) & G (s -> g)))
+LTLSPEC !((G F person | !((G F person -> G (greet <-> person)) & (G F person -> G (person <-> X register)))) & ((G F (r1 & F r2) & (!r2 U r1) & G (r2 -> X (!r2 U r1)) & G (r1 -> X (!r1 U r2)) & (G F person -> G (greet <-> person)) & (G F person -> G (person <-> X register))) | !(G F person | !((G F person -> G (greet <-> person)) & (G F person -> G (person <-> X register))))) & ((G F (r3 & F r4) & (!r4 U r3) & G (r4 -> X (!r4 U r3)) & G (r3 -> X (!r3 U r4)) & (G F person -> G (greet <-> person))) | !G F person) & G ((!r1 & r2 & !r3 & !r4) | (!r1 & !r2 & !r3 & r4) | (!r1 & !r2 & r3 & !r4) | (r1 & !r2 & !r3 & !r4)) & G (!r2 | X r2) & G (!r3 | X r3) & G (!r4 | X r4))
Index: crome_logic/typeset/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\n\nfrom copy import copy, deepcopy\nfrom typing import Iterable\n\nfrom crome_logic.tools.atomic_propositions import extract_ap\nfrom crome_logic.typelement import AnyCromeType, TypeKind, CromeType\nfrom crome_logic.typelement.basic import (\n    Boolean,\n    BooleanControllable,\n    BooleanUncontrollable,\n    BoundedInteger,\n)\n\nBASE_CLASS_TYPES = [\n    \"Boolean\",\n    \"BoundedInteger\",\n    \"BooleanAction\",\n    \"IntegerAction\",\n    \"Active\",\n    \"ContextTime\",\n    \"ContextBooleanTime\",\n    \"ContextLocation\",\n    \"ContextIdentity\",\n    \"ReachLocation\",\n    \"IntegerSensor\",\n    \"BooleanSensor\",\n]\n\n\nclass Typeset(dict[str, AnyCromeType]):\n    \"\"\"set of identifier -> Boolean.\"\"\"\n\n    def __init__(self, types: set[AnyCromeType] | None = None):\n        \"\"\"Indicates the supertypes relationships for each typelement in the\n        typeset.\"\"\"\n        self._super_types: dict[AnyCromeType, set[AnyCromeType]] = {}\n        \"\"\"Indicates the mutex relationships for the typelement in the typeset\"\"\"\n        self._mutex_types: set[frozenset[Boolean]] = set()\n        \"\"\"Indicates the adjacency relationships for the typelement in the typeset\"\"\"\n        self._adjacent_types: dict[Boolean, set[Boolean]] = {}\n\n        if types is not None and len(types) > 0:\n            self._add_elements(types)\n        else:\n            super().__init__()\n\n    @classmethod\n    def from_aps(\n            cls,\n            controllable: set[str] | None = None,\n            uncontrollable: set[str] | None = None,\n    ) -> Typeset:\n\n        crome_types: set[Boolean] = set()\n        if controllable is not None:\n            for ap in controllable:\n                crome_types.add(BooleanControllable(name=ap))\n\n        if uncontrollable is not None:\n            for ap in uncontrollable:\n                crome_types.add(BooleanUncontrollable(name=ap))\n\n        return cls(crome_types)  # type: ignore\n\n    @classmethod\n    def from_typesets(\n            cls,\n            typesets: Iterable[Typeset]\n    ) -> Typeset:\n\n        typeset = cls()\n\n        for t in typesets:\n            typeset += t\n\n        return typeset\n\n    def __setitem__(self, name, elem):\n        self._add_elements({elem})\n\n    def __deepcopy__(self: Typeset, memo):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n        for k, v in self.__dict__.items():\n            setattr(result, k, deepcopy(v))\n        \"\"\"Do not perform a deepcopy of the variables\"\"\"\n        for k, v in self.items():\n            result[k] = v\n        return result\n\n    def __str__(self):\n        ret = \"\"\n        for (key, elem) in self.items():\n            ret += f\"{key}:\\t{elem.name}\"\n            if elem in self.super_types:\n                ret += \" -> \"\n                for supertypes in self.super_types[elem]:\n                    ret += supertypes.name\n            ret += \"\\n\"\n        return ret[:-1]\n\n    def __add__(self, element: Typeset | Boolean) -> Typeset:\n        \"\"\"Returns self + element.\n\n        WARNING: violates Liskov Substitution Principle\n        \"\"\"\n        if isinstance(element, Boolean):\n            element = Typeset({element})\n        \"\"\"Shallow copy\"\"\"\n        new_dict = copy(self)\n        new_dict.__iadd__(element)\n        return new_dict\n\n    def __sub__(self, element: Typeset | Boolean) -> Typeset:\n        \"\"\"Returns self - element\"\"\"\n        if isinstance(element, Boolean):\n            element = Typeset({element})\n        \"\"\"Shallow copy\"\"\"\n        new_dict = copy(self)\n        for key in element.keys():\n            if key in new_dict:\n                del new_dict[key]\n        return new_dict\n\n    def __iadd__(self, element: Typeset | Boolean):\n        \"\"\"Updates self with self += element.\"\"\"\n        if isinstance(element, Boolean):\n            element = Typeset({element})\n        for key, value in element.items():\n            if key in self:\n                if type(value).__name__ != type(self[key]).__name__:\n                    print(\n                        f\"Trying to add an element with key '{key}' and value of typelement '{type(value).__name__}'\"\n                    )\n                    print(\n                        f\"ERROR:\\n\"\n                        f\"There is already en element with key '{key}' and value of typelement '{type(self[key]).__name__}'\"\n                    )\n                    raise Exception(\"Type Mismatch\")\n            if key not in self:\n                self._add_elements({value})\n        return self\n\n    @property\n    def size(self) -> int:\n        return len(list(self.keys()))\n\n    def to_str_nuxmv(self) -> list[str]:\n        tuple_vars = []\n        for k, v in self.items():\n            if isinstance(v, Boolean):\n                tuple_vars.append(f\"{k}: boolean\")\n            elif isinstance(v, BoundedInteger):\n                tuple_vars.append(f\"{k}: {v.min}..{v.max}\")\n        return tuple_vars\n\n    def get_sub_typeset(self, formula: str):\n        set_ap_str = extract_ap(formula)\n        set_of_types = set(filter((lambda x: x.name in set_ap_str), self.values()))\n        return Typeset(set_of_types)\n\n    def _add_elements(self, types: set[AnyCromeType]):\n        if types is not None:\n            for elem in types:\n                super().__setitem__(elem.name, elem)\n\n        self._update_refinements()\n        self._update_mutex()\n        self._update_adjacency()\n\n    def _update_refinements(self) -> None:\n        \"\"\"Updates the refinement relationships in the typeset.\"\"\"\n        if len(self.values()) > 1:\n            for element in self.values():\n                for super_type in element.refinement_of:\n                    if super_type in self.keys():\n                        if element in self._super_types.keys():\n                            self._super_types[element].add(self[super_type])\n                        else:\n                            self._super_types[element] = {self[super_type]}\n\n    def _update_mutex(self) -> None:\n        \"\"\"Updates the mutually exclusion relationships in the typeset.\"\"\"\n        if len(self.values()) > 1:\n            self._mutex_types = set()\n            mutex_vars_dict: dict[str, set[Boolean]] = {}\n            for variable in self.values():\n                if isinstance(variable, Boolean):\n                    if variable.mutex_group != \"\":\n                        if variable.mutex_group in mutex_vars_dict:\n                            mutex_vars_dict[variable.mutex_group].add(variable)\n                        else:\n                            mutex_vars_dict[variable.mutex_group] = set()\n                            mutex_vars_dict[variable.mutex_group].add(variable)\n            for vars in mutex_vars_dict.values():\n                self._mutex_types.add(frozenset(vars))\n\n    def _update_adjacency(self) -> None:\n        \"\"\"Updates the adjacency relationships in the typeset.\"\"\"\n        if len(self.values()) > 1:\n            self._adjacent_types = {}\n            for variable in self.values():\n                if isinstance(variable, Boolean):\n                    if len(list(variable.adjacency_set)) != 0:\n                        self._adjacent_types[variable] = {variable}\n                        adjacent_types = filter(lambda x: x.name in variable.adjacency_set, self.values())\n                        self._adjacent_types[variable] |= set(adjacent_types)\n\n    @property\n    def super_types(self) -> dict[AnyCromeType, set[AnyCromeType]]:\n        return self._super_types\n\n    @property\n    def mutex_types(self) -> set[frozenset[Boolean]]:\n        return self._mutex_types\n\n    @property\n    def adjacent_types(self) -> dict[Boolean, set[Boolean]]:\n        return self._adjacent_types\n\n    def similar_types(self, other: Typeset) -> set[CromeType]:\n        \"\"\"Returns the types that are 'similar' to the types in typeset\n        \"\"\"\n        similar_types: set[CromeType] = set()\n        for st in self.values():\n            for ot in other.values():\n                if st.is_similar_to(ot):\n                    similar_types.add(st)\n        return similar_types\n\n    def similarity_score(self, other: Typeset) -> float:\n        \"\"\"Returns the percentage of types similar to 'other'\n        \"\"\"\n        return len(self.similar_types(other)) / other.size * 100\n\n    def extract_inputs_outputs(\n            self, string: bool = False\n    ) -> tuple[set[Boolean], set[Boolean]] | tuple[set[str], list[str]]:\n        \"\"\"Returns a set of variables in the typeset that are not controllable\n        and controllable.\"\"\"\n        i: set[Boolean] = set()\n        i_str: set[str] = set()\n        o: set[Boolean] = set()\n        o_str: set[str] = set()\n        if len(self.values()) > 0:\n            for t in self.values():\n                if isinstance(t, Boolean):\n                    if not t.controllable:\n                        if string:\n                            i_str.add(t.name)\n                        else:\n                            i.add(t)\n                    else:\n                        if string:\n                            o_str.add(t.name)\n                        else:\n                            o.add(t)\n        if string:\n            return i_str, o_str\n        return list(i), list(o)\n\n    def extract_viewpoint(self):\n        for v in self.values():\n            if v.kind == TypeKind.LOCATION:\n                return \"location\"\n            elif v.kind == TypeKind.ACTION:\n                return \"action\"\n        return \"other\"\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crome_logic/typeset/__init__.py b/crome_logic/typeset/__init__.py
--- a/crome_logic/typeset/__init__.py	(revision ccbaf32c1b4bd5f61f4943b973848d7597f82211)
+++ b/crome_logic/typeset/__init__.py	(date 1653702176675)
@@ -223,11 +223,13 @@
     def similar_types(self, other: Typeset) -> set[CromeType]:
         """Returns the types that are 'similar' to the types in typeset
         """
+        similar_to: set[CromeType] = set()
         similar_types: set[CromeType] = set()
         for st in self.values():
             for ot in other.values():
-                if st.is_similar_to(ot):
+                if st.is_similar_to(ot) and ot not in similar_to:
                     similar_types.add(st)
+                    similar_to.add(ot)
         return similar_types
 
     def similarity_score(self, other: Typeset) -> float:
Index: examples/temporal.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from copy import deepcopy\n\nfrom crome_cgg.context import Context\nfrom crome_logic.specification.temporal import LTL\nfrom crome_logic.typelement.robotic import BooleanContext\nfrom crome_logic.typeset import Typeset\n\n\ndef example_1() -> None:\n    phi = \"! z & G(a & b | G(k & l)) & F(c | !d) & (X(e & f) | !X(g | h)) & (l U p)\"\n    ltl = LTL(phi)\n    lel2 = deepcopy(ltl)\n    assert ltl == lel2\n    print(ltl.tree)\n    print(ltl.boolean.tree)\n    print(ltl.print_summary)\n\n\ndef sat1() -> None:\n    phi = \"a & b\"\n    ltl = LTL(phi)\n    print(ltl.is_satisfiable)\n\n    phi = \"a & !a\"\n    ltl = LTL(phi)\n    print(ltl.is_satisfiable)\n\n\ndef val1() -> None:\n    phi = \"a & !a\"\n    ltl = LTL(phi)\n    print(ltl.is_valid)\n\n    phi = \"a | !a\"\n    ltl = LTL(phi)\n    print(ltl.is_valid)\n\n\ndef simplify() -> None:\n    phi1 = LTL(\"TRUE\")\n    phi2 = LTL(\"a\")\n    print(phi1 & phi2)\n    print(phi1 | phi2)\n    phi2 &= phi1\n    print(phi2)\n    phi2 |= phi1\n    print(phi2)\n\n\n\ndef sat_example():\n    day = Context(\"day\")\n    night = Context(\"night\")\n    c = day & night\n    print(c.is_satisfiable)\n    print(c)\n\n\ndef unsat_example():\n    typeset = Typeset({\n        BooleanContext(name=\"day\", mutex_group=\"time\"),\n        BooleanContext(name=\"night\", mutex_group=\"time\"),\n    })\n    day = Context(_init_formula=\"day\", _typeset=typeset)\n    night = Context(_init_formula=\"night\", _typeset=typeset)\n    c = day & night\n    print(c.is_satisfiable)\n    print(c)\n    c = day | night\n    print(c.is_satisfiable)\n    print(c)\n\n\nif __name__ == '__main__':\n    unsat_example()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/examples/temporal.py b/examples/temporal.py
--- a/examples/temporal.py	(revision ccbaf32c1b4bd5f61f4943b973848d7597f82211)
+++ b/examples/temporal.py	(date 1654109844250)
@@ -13,7 +13,7 @@
     assert ltl == lel2
     print(ltl.tree)
     print(ltl.boolean.tree)
-    print(ltl.print_summary)
+    print(ltl.summary)
 
 
 def sat1() -> None:
Index: crome_logic/specification/temporal/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\n\nfrom copy import deepcopy\nfrom dataclasses import dataclass, fields\n\nimport spot\nfrom treelib import Tree\n\nfrom crome_logic.patterns import Pattern\nfrom crome_logic.specification import Cnf, Dnf, Specification\nfrom crome_logic.specification.boolean import Bool\nfrom crome_logic.specification.temporal.tools import transform_spot_tree\nfrom crome_logic.specification.tools import is_true_string\nfrom crome_logic.specification.trees import (\n    boolean_tree_to_formula,\n    extract_atoms_dictionary,\n    gen_atoms_tree,\n    gen_ltl_tree,\n)\nfrom crome_logic.tools.atomic_propositions import extract_ap\nfrom crome_logic.tools.nuxmv import check_satisfiability, check_validity\nfrom crome_logic.typelement.basic import Boolean\nfrom crome_logic.typeset import Typeset\n\n\n@dataclass(frozen=True)\nclass LTL(Specification):\n    _init_formula: str | Pattern\n    _typeset: Typeset | None = None\n    _boolean: Bool | None = None\n    _kind: Specification.Kind = Specification.Kind.UNDEFINED\n    _expression: spot.formula | None = None\n    _tree: Tree | None = None\n\n    @property\n    def boolean(self) -> Bool:\n        if isinstance(self._boolean, Bool):\n            return self._boolean\n        raise AttributeError\n\n    @property\n    def kind(self) -> Specification.Kind:\n        return self._kind\n\n    @property\n    def expression(self) -> spot.formula:\n        return self._expression\n\n    @property\n    def tree(self) -> Tree:\n        return self._tree\n\n    def __post_init__(self):\n        if isinstance(self._init_formula, Pattern):\n            object.__setattr__(self, \"_init_formula\", str(self._init_formula))\n        self._initialize_external_libraries_objects(self._init_formula)\n\n        if self._typeset is None:\n            set_ap_str = extract_ap(self.expression)\n            set_ap = set(map(lambda x: Boolean(name=x), set_ap_str))\n            typeset = Typeset(set_ap)\n        else:\n            typeset = self.typeset.get_sub_typeset(str(self.expression))\n        object.__setattr__(self, \"_typeset\", typeset)\n\n    def _initialize_external_libraries_objects(self, formula: str):\n        expression = transform_spot_tree(spot.formula(formula))\n        object.__setattr__(self, \"_expression\", expression)\n        if self._boolean is None:\n            atom_tree = gen_atoms_tree(spot_f=self.expression)\n            boolean = Bool(\n                _init_formula=boolean_tree_to_formula(atom_tree), _tree=atom_tree\n            )\n            object.__setattr__(self, \"_boolean\", boolean)\n        tree: Tree = gen_ltl_tree(spot_f=self.expression)\n        object.__setattr__(self, \"_tree\", tree)\n\n    @classmethod\n    def from_pattern(cls, formula: Pattern, typeset: Typeset | None = None) -> LTL:\n        return cls(_init_formula=str(formula), _typeset=typeset)\n\n    def __hash__(self: LTL):\n        return hash(str(self))\n\n    @property\n    def formula(self) -> str:\n        return str(self.expression)\n\n\n    @property\n    def typeset_complete(self) -> Typeset:\n        return self.typeset + self.refinement_rules.typeset + self.adjacency_and_mutex_rules.typeset\n\n    def __str__(self):\n        return self.formula\n\n    def __deepcopy__(self: LTL, memo):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        for field in fields(cls):\n            if not (\n                    field.name == \"_boolean\"\n                    or field.name == \"_expression\"\n                    or field.name == \"_tree\"\n            ):\n                object.__setattr__(\n                    result, field.name, deepcopy(getattr(self, field.name))\n                )\n        result._initialize_external_libraries_objects(result.init_formula)\n        return result\n\n    @property\n    def print_summary(self) -> str:\n        ret = (\n            f\"\\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\"\n            f\"LTL SIMPLIFIED\\n\"\n            f\"{str(self)}\\n\\n\"\n            f\"BOOLEAN REPRESENTATION\\n\"\n            f\"{str(self.boolean)}\\n\\n\"\n            f\"LTL CNF (from booleans)\\n\"\n            f\"{self.cnf.to_str}\\n\\n\"\n            f\"LTL DNF (from booleans)\\n\"\n            f\"{self.dnf.to_str}\\n\"\n            f\"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n\\n\"\n        )\n        return ret\n\n    @property\n    def cnf(self) -> Cnf:\n        atoms_cnf = self.boolean.cnf.clauses\n        cnf_list = []\n        atoms_dictionary = extract_atoms_dictionary(self.boolean.tree)\n        for clauses in atoms_cnf:\n            atoms = set()\n            for atom in clauses:\n                atom_str: str = str(atom)\n                if atom_str.startswith(\"!\"):\n                    ltl_formula = f\"!{atoms_dictionary[atom_str[1:]]}\"\n                else:\n                    ltl_formula = atoms_dictionary[str(atom)]\n                ltl_object = LTL(\n                    _init_formula=ltl_formula,\n                    _typeset=self.typeset.get_sub_typeset(ltl_formula),\n                )\n                atoms.add(ltl_object)\n            cnf_list.append(atoms)\n        return Cnf(cnf_list)  # type: ignore\n\n    @property\n    def dnf(self) -> Dnf:\n        atoms_dnf = self.boolean.dnf.clauses\n        dnf_list = []\n        atoms_dictionary = extract_atoms_dictionary(self.boolean.tree)\n        for clauses in atoms_dnf:\n            atoms = set()\n            for atom in clauses:\n                atom_str: str = str(atom)\n                if atom_str.startswith(\"!\"):\n                    ltl_formula = f\"!{atoms_dictionary[atom_str[1:]]}\"\n                else:\n                    ltl_formula = atoms_dictionary[str(atom)]\n                ltl_object = LTL(\n                    _init_formula=ltl_formula,\n                    _typeset=self.typeset.get_sub_typeset(ltl_formula),\n                )\n                atoms.add(ltl_object)\n            dnf_list.append(atoms)\n        return Dnf(dnf_list)  # type: ignore\n\n    def __iand__(self: Specification, other: Specification) -> LTL:\n        \"\"\"self &= other Modifies self with the conjunction with other.\"\"\"\n        if not (isinstance(self, LTL) and isinstance(other, LTL)):\n            raise AttributeError\n        if self.is_true_expression:\n            init_formula = deepcopy(other.formula)\n            typeset = deepcopy(other.typeset)\n            boolean = deepcopy(other.boolean)\n            object.__setattr__(self, \"_init_formula\", init_formula)\n            object.__setattr__(self, \"_typeset\", typeset)\n            object.__setattr__(self, \"_boolean\", boolean)\n\n            self.__post_init__()  # type: ignore\n\n            return self\n\n        if other.is_true_expression:\n            return self\n\n        init_formula = f\"({str(self)}) & ({str(other)})\"\n        typeset = self.typeset + other.typeset\n        boolean = self.boolean & other.boolean\n\n        object.__setattr__(self, \"_init_formula\", init_formula)\n        object.__setattr__(self, \"_typeset\", typeset)\n        object.__setattr__(self, \"_boolean\", boolean)\n\n        self.__post_init__()  # type: ignore\n\n        return self\n\n    def __ior__(self: Specification, other: Specification) -> LTL:\n        \"\"\"self |= other Modifies self with the disjunction with other.\"\"\"\n        if not (isinstance(self, LTL) and isinstance(other, LTL)):\n            raise AttributeError\n        if self.is_true_expression or other.is_true_expression:\n            init_formula = f\"TRUE\"\n        else:\n            init_formula = f\"({str(self)}) | ({str(other)})\"\n\n        typeset = self.typeset + other.typeset\n        boolean = self.boolean | other.boolean\n        object.__setattr__(self, \"_init_formula\", init_formula)\n        object.__setattr__(self, \"_typeset\", typeset)\n        object.__setattr__(self, \"_boolean\", boolean)\n\n        self.__post_init__()  # type: ignore\n\n        return self\n\n    def __and__(self: Specification, other: Specification) -> LTL:\n        \"\"\"self & other Returns a new LTL with the conjunction with other.\"\"\"\n        if not (isinstance(self, LTL) and isinstance(other, LTL)):\n            raise AttributeError\n        if self.is_true_expression:\n            return LTL(\n                _init_formula=str(other),\n                _boolean=other.boolean,\n                _typeset=other.typeset,\n            )\n\n        if other.is_true_expression:\n            return LTL(\n                _init_formula=str(self),\n                _boolean=self.boolean,\n                _typeset=self.typeset,\n            )\n\n        return LTL(\n            _init_formula=f\"({str(self)}) & ({str(other)})\",\n            _boolean=self.boolean & other.boolean,\n            _typeset=self.typeset + other.typeset,\n        )\n\n    def __or__(self: Specification, other: Specification) -> LTL:\n        \"\"\"self | other Returns a new LTL with the disjunction with other.\"\"\"\n        if not (isinstance(self, LTL) and isinstance(other, LTL)):\n            raise AttributeError\n        if self.is_true_expression or other.is_true_expression:\n            return LTL(\"TRUE\")\n\n        return LTL(\n            _init_formula=f\"({str(self)}) | ({str(other)})\",\n            _boolean=self.boolean | other.boolean,\n            _typeset=self.typeset + other.typeset,\n        )\n\n    def __invert__(self: Specification) -> LTL:\n        \"\"\"Returns a new LTL with the negation of self.\"\"\"\n        if not isinstance(self, LTL):\n            raise AttributeError\n        return LTL(\n            _init_formula=f\"!({self.expression})\",\n            _boolean=~self.boolean,\n            _typeset=self.typeset,\n        )\n\n    def __rshift__(self: Specification, other: Specification) -> LTL:\n        \"\"\">> Returns a new LTL that is the result of self -> other\n        (implies)\"\"\"\n        if not (isinstance(self, LTL) and isinstance(other, LTL)):\n            raise AttributeError\n        if self.is_true_expression:\n            return LTL(\n                _init_formula=str(other),\n                _boolean=other.boolean,\n                _typeset=other.typeset,\n            )\n\n        return LTL(\n            _init_formula=f\"({self.expression}) -> ({other.expression})\",\n            _boolean=self.boolean >> other.boolean,\n            _typeset=self.typeset + other.typeset,\n        )\n\n    @property\n    def adjacency_and_mutex_rules(self) -> LTL:\n        from crome_logic.specification.rules_extractors import (\n            extract_adjacency_rules, extract_mutex_rules\n        )\n\n        return extract_mutex_rules(self.typeset) & extract_adjacency_rules(self.typeset)\n\n    @property\n    def refinement_rules(self) -> LTL:\n        from crome_logic.specification.rules_extractors import (\n            extract_refinement_rules\n        )\n\n        return extract_refinement_rules(self.typeset)\n\n    @property\n    def is_satisfiable(self: LTL) -> bool:\n\n        new_f = self & self.adjacency_and_mutex_rules\n\n        return check_satisfiability(str(new_f), new_f.typeset.to_str_nuxmv())\n\n    @property\n    def is_valid(self: LTL) -> bool:\n\n        if isinstance(self.kind, LTL.Kind.Rule):\n            return check_validity(str(self), self.typeset.to_str_nuxmv())\n\n        new_f = self.refinement_rules >> self\n\n        return check_validity(str(new_f), new_f.typeset.to_str_nuxmv())\n\n    @property\n    def is_true_expression(self) -> bool:\n        if is_true_string(str(self)):\n            return True\n\n    def __lt__(self, other: LTL):\n        \"\"\"self < other.\n\n        True if self is a refinement but not equal to other\n        \"\"\"\n        return self.__le__(other) and self.__ne__(other)\n\n    def __le__(self: LTL, other: LTL):\n        \"\"\"self <= other.\n\n        True if self is a refinement of other\n        \"\"\"\n        \"\"\"Check if (self -> other) is valid\"\"\"\n        return (self >> other).is_valid\n\n    def __gt__(self, other: LTL):\n        \"\"\"self > other.\n\n        True if self is an abstraction but not equal to other\n        \"\"\"\n        return self.__ge__(other) and self.__ne__(other)\n\n    def __ge__(self, other: LTL):\n        \"\"\"self >= other.\n\n        True if self is an abstraction of other\n        \"\"\"\n        \"\"\"Check if (other -> self) is valid\"\"\"\n        return (other >> self).is_valid\n\n    def __eq__(self, other: object):\n        \"\"\"Check if self == other.\"\"\"\n        if not isinstance(other, LTL):\n            return NotImplemented\n        if str(self) == str(other):\n            return True\n        else:\n            not_self = ~self\n            if str(not_self) == str(other):\n                return False\n            return self.__le__(other) and self.__ge__(other)\n\n    def __ne__(self, other: object):\n        \"\"\"Check if self != other.\"\"\"\n        if not isinstance(other, LTL):\n            return NotImplemented\n        return not self.__eq__(other)\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        del state[\"_tree\"]\n        state[\"_expression\"] = str(self.expression)\n        state[\"_boolean\"] = str(self.boolean)\n        state[\"_boolean_typeset\"] = self.boolean.typeset\n\n        return state\n\n    def __setstate__(self, state):\n        expression = state[\"_expression\"]\n        boolean = state[\"_boolean\"]\n        boolean_typeset = state[\"_boolean_typeset\"]\n        del state[\"_expression\"]\n        del state[\"_boolean\"]\n        del state[\"_boolean_typeset\"]\n        self.__dict__.update(state)\n        init_formula = expression\n        boolean = Bool(_init_formula=boolean, _typeset=boolean_typeset)\n        object.__setattr__(self, \"_init_formula\", init_formula)\n        object.__setattr__(self, \"_boolean\", boolean)\n        self.__post_init__()  # type: ignore\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crome_logic/specification/temporal/__init__.py b/crome_logic/specification/temporal/__init__.py
--- a/crome_logic/specification/temporal/__init__.py	(revision ccbaf32c1b4bd5f61f4943b973848d7597f82211)
+++ b/crome_logic/specification/temporal/__init__.py	(date 1654110169887)
@@ -110,7 +110,9 @@
         return result
 
     @property
-    def print_summary(self) -> str:
+    def summary(self) -> str:
+        cnf_list = "\n".join(self.cnf.to_str_list)
+        dnf_list = "\n".join(self.dnf.to_str_list)
         ret = (
             f"\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"
             f"LTL SIMPLIFIED\n"
@@ -118,9 +120,13 @@
             f"BOOLEAN REPRESENTATION\n"
             f"{str(self.boolean)}\n\n"
             f"LTL CNF (from booleans)\n"
-            f"{self.cnf.to_str}\n\n"
+            f"{self.cnf.to_str}\n"
+            f"LTL CNF (list)\n"
+            f"{cnf_list}\n\n"
             f"LTL DNF (from booleans)\n"
             f"{self.dnf.to_str}\n"
+            f"LTL DNF (list)\n"
+            f"{dnf_list}\n"
             f"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n"
         )
         return ret
